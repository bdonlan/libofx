<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>LibOFX: tree&lt; T, tree_node_allocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">LibOFX</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classtree.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Data Fields</a> &#124;
<a href="#pro-types">Protected Types</a>  </div>
  <div class="headertitle">
<h1>tree&lt; T, tree_node_allocator &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="tree" --><table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>compare_nodes</b></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparator class for two nodes of a tree (used for sorting and searching). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree_1_1fixed__depth__iterator.html">fixed_depth_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator which traverses only the nodes at a given depth from the root.  <a href="classtree_1_1fixed__depth__iterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree_1_1iterator__base.html">iterator_base</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for iterators, only pointers stored, no traversal logic.  <a href="classtree_1_1iterator__base.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree_1_1iterator__base__less.html">iterator_base_less</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparator class for iterators (compares the actual node content, not pointer values).  <a href="classtree_1_1iterator__base__less.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree_1_1post__order__iterator.html">post_order_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Depth-first iterator, first accessing the children, then the node itself.  <a href="classtree_1_1post__order__iterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree_1_1pre__order__iterator.html">pre_order_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Depth-first iterator, first accessing the node, then its children.  <a href="classtree_1_1pre__order__iterator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator which traverses only the nodes which are siblings of each other.  <a href="classtree_1_1sibling__iterator.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e7bcd21e7420f7922a1bca79080acfa"></a><!-- doxytag: member="tree::value_type" ref="a1e7bcd21e7420f7922a1bca79080acfa" args="" -->
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a1e7bcd21e7420f7922a1bca79080acfa">value_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Value of the data stored at a node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2079982538b88d21fe1ccea34fe7ce0e"></a><!-- doxytag: member="tree::iterator" ref="a2079982538b88d21fe1ccea34fe7ce0e" args="" -->
typedef <a class="el" href="classtree_1_1pre__order__iterator.html">pre_order_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a2079982538b88d21fe1ccea34fe7ce0e">iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The default iterator type throughout the tree class. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e7bcd21e7420f7922a1bca79080acfa"></a><!-- doxytag: member="tree::value_type" ref="a1e7bcd21e7420f7922a1bca79080acfa" args="" -->
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a1e7bcd21e7420f7922a1bca79080acfa">value_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Value of the data stored at a node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2079982538b88d21fe1ccea34fe7ce0e"></a><!-- doxytag: member="tree::iterator" ref="a2079982538b88d21fe1ccea34fe7ce0e" args="" -->
typedef <a class="el" href="classtree_1_1pre__order__iterator.html">pre_order_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a2079982538b88d21fe1ccea34fe7ce0e">iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The default iterator type throughout the tree class. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5925c012af64fe91a3a5ed39e3ba9d9a"></a><!-- doxytag: member="tree::tree" ref="a5925c012af64fe91a3a5ed39e3ba9d9a" args="(const T &amp;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>tree</b> (const T &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab72378e7a772a82f90d91ef7493f27bc"></a><!-- doxytag: member="tree::tree" ref="ab72378e7a772a82f90d91ef7493f27bc" args="(const iterator_base &amp;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>tree</b> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9e06b40929dfd33a1024bd422beedb6"></a><!-- doxytag: member="tree::tree" ref="ae9e06b40929dfd33a1024bd422beedb6" args="(const tree&lt; T, tree_node_allocator &gt; &amp;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>tree</b> (const <a class="el" href="classtree.html">tree</a>&lt; T, tree_node_allocator &gt; &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9561c0c73b0605f32bf82a026eaf216a"></a><!-- doxytag: member="tree::operator=" ref="a9561c0c73b0605f32bf82a026eaf216a" args="(const tree&lt; T, tree_node_allocator &gt; &amp;)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classtree.html">tree</a>&lt; T, tree_node_allocator &gt; &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76b3a629c0208d5ae5b4ffcd4492e05e"></a><!-- doxytag: member="tree::begin" ref="a76b3a629c0208d5ae5b4ffcd4492e05e" args="() const " -->
<a class="el" href="classtree_1_1pre__order__iterator.html">pre_order_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a76b3a629c0208d5ae5b4ffcd4492e05e">begin</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator to the beginning of the tree. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d09fe9fd34fbfc9c9e4e28cb694448e"></a><!-- doxytag: member="tree::end" ref="a0d09fe9fd34fbfc9c9e4e28cb694448e" args="() const " -->
<a class="el" href="classtree_1_1pre__order__iterator.html">pre_order_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a0d09fe9fd34fbfc9c9e4e28cb694448e">end</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator to the end of the tree. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73c673d39fe46db7ca4e1533841cdbc0"></a><!-- doxytag: member="tree::begin_post" ref="a73c673d39fe46db7ca4e1533841cdbc0" args="() const " -->
<a class="el" href="classtree_1_1post__order__iterator.html">post_order_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a73c673d39fe46db7ca4e1533841cdbc0">begin_post</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return post-order iterator to the beginning of the tree. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad339ab550fc2718e84506e91960a177f"></a><!-- doxytag: member="tree::end_post" ref="ad339ab550fc2718e84506e91960a177f" args="() const " -->
<a class="el" href="classtree_1_1post__order__iterator.html">post_order_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#ad339ab550fc2718e84506e91960a177f">end_post</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return post-order iterator to the end of the tree. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e7ee34b9582cb6f0bd5b25f501a1057"></a><!-- doxytag: member="tree::begin_fixed" ref="a3e7ee34b9582cb6f0bd5b25f501a1057" args="(const iterator_base &amp;, unsigned int) const " -->
<a class="el" href="classtree_1_1fixed__depth__iterator.html">fixed_depth_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a3e7ee34b9582cb6f0bd5b25f501a1057">begin_fixed</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;, unsigned int) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return fixed-depth iterator to the first node at a given depth. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abab26c0edd25cc836ed768e32c034165"></a><!-- doxytag: member="tree::end_fixed" ref="abab26c0edd25cc836ed768e32c034165" args="(const iterator_base &amp;, unsigned int) const " -->
<a class="el" href="classtree_1_1fixed__depth__iterator.html">fixed_depth_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#abab26c0edd25cc836ed768e32c034165">end_fixed</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;, unsigned int) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return fixed-depth iterator to end of the nodes at given depth. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa784ffa6dec85f52754dde8bd6a99aeb"></a><!-- doxytag: member="tree::begin" ref="aa784ffa6dec85f52754dde8bd6a99aeb" args="(const iterator_base &amp;) const " -->
<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#aa784ffa6dec85f52754dde8bd6a99aeb">begin</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return sibling iterator to the first child of given node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6aa8b0c6af0f50bfc86592847759127"></a><!-- doxytag: member="tree::end" ref="aa6aa8b0c6af0f50bfc86592847759127" args="(const iterator_base &amp;) const " -->
<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#aa6aa8b0c6af0f50bfc86592847759127">end</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return sibling iterator to the end of the children of a given node. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aaaaa1622d2d58ecda846640bd8f8bd28"></a><!-- doxytag: member="tree::parent" ref="aaaaa1622d2d58ecda846640bd8f8bd28" args="(iter) const " -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#aaaaa1622d2d58ecda846640bd8f8bd28">parent</a> (iter) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator to the parent of a node. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a6d38ef0b2b73266cbc39ab021482bb50"></a><!-- doxytag: member="tree::previous_sibling" ref="a6d38ef0b2b73266cbc39ab021482bb50" args="(iter) const " -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#a6d38ef0b2b73266cbc39ab021482bb50">previous_sibling</a> (iter) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator to the previous sibling of a node. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a4e3ea50e0949bd05e27ecb9c6b7162ff"></a><!-- doxytag: member="tree::next_sibling" ref="a4e3ea50e0949bd05e27ecb9c6b7162ff" args="(iter) const " -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#a4e3ea50e0949bd05e27ecb9c6b7162ff">next_sibling</a> (iter) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator to the next sibling of a node. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ace3b299e157ec177230a0144771b2a7e"></a><!-- doxytag: member="tree::next_at_same_depth" ref="ace3b299e157ec177230a0144771b2a7e" args="(iter) const " -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#ace3b299e157ec177230a0144771b2a7e">next_at_same_depth</a> (iter) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator to the next node at a given depth. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8cf6dfe17504abfc0ffabb5a4ba9d0a"></a><!-- doxytag: member="tree::clear" ref="aa8cf6dfe17504abfc0ffabb5a4ba9d0a" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#aa8cf6dfe17504abfc0ffabb5a4ba9d0a">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all nodes of the tree. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a3eb424c89446ae17a747d2aca2cdda4b"></a><!-- doxytag: member="tree::erase" ref="a3eb424c89446ae17a747d2aca2cdda4b" args="(iter)" -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#a3eb424c89446ae17a747d2aca2cdda4b">erase</a> (iter)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase element at position pointed to by iterator, return incremented iterator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05d5fd71c206efc8ac30df5cd46176bc"></a><!-- doxytag: member="tree::erase_children" ref="a05d5fd71c206efc8ac30df5cd46176bc" args="(const iterator_base &amp;)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a05d5fd71c206efc8ac30df5cd46176bc">erase_children</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all children of the node pointed to by iterator. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a8d68e95f5088d48cb54fd6ae381729f0"></a><!-- doxytag: member="tree::append_child" ref="a8d68e95f5088d48cb54fd6ae381729f0" args="(iter position)" -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#a8d68e95f5088d48cb54fd6ae381729f0">append_child</a> (iter <a class="el" href="fx-0_89_84_2lib_2ofx__sgml_8cpp.html#a4da8008b6f110050513003edf67a2495">position</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert empty node as last child of node pointed to by position. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a9318fa77c4e10ec0a9a26a0d08f182a2"></a><!-- doxytag: member="tree::append_child" ref="a9318fa77c4e10ec0a9a26a0d08f182a2" args="(iter position, const T &amp;x)" -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#a9318fa77c4e10ec0a9a26a0d08f182a2">append_child</a> (iter <a class="el" href="fx-0_89_84_2lib_2ofx__sgml_8cpp.html#a4da8008b6f110050513003edf67a2495">position</a>, const T &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert node as last child of node pointed to by position. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a1fb4734b783fed4a66c24130af67316e"></a><!-- doxytag: member="tree::append_child" ref="a1fb4734b783fed4a66c24130af67316e" args="(iter position, iter other_position)" -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#a1fb4734b783fed4a66c24130af67316e">append_child</a> (iter <a class="el" href="fx-0_89_84_2lib_2ofx__sgml_8cpp.html#a4da8008b6f110050513003edf67a2495">position</a>, iter other_position)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the node (plus its children) at other_position as a child of position. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a92ab22e0a98d8899c0d1b6c9d0a85465"></a><!-- doxytag: member="tree::append_children" ref="a92ab22e0a98d8899c0d1b6c9d0a85465" args="(iter position, sibling_iterator from, sibling_iterator to)" -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#a92ab22e0a98d8899c0d1b6c9d0a85465">append_children</a> (iter <a class="el" href="fx-0_89_84_2lib_2ofx__sgml_8cpp.html#a4da8008b6f110050513003edf67a2495">position</a>, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> from, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> to)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the nodes in the from-to range (plus their children) as children of position. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af11d736ea971ab93651350161f5a7535"></a><!-- doxytag: member="tree::set_head" ref="af11d736ea971ab93651350161f5a7535" args="(const T &amp;x)" -->
<a class="el" href="classtree_1_1pre__order__iterator.html">pre_order_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#af11d736ea971ab93651350161f5a7535">set_head</a> (const T &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand to insert topmost node in otherwise empty tree. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ac3d19d3a42f91618267674f2c236aad9"></a><!-- doxytag: member="tree::insert" ref="ac3d19d3a42f91618267674f2c236aad9" args="(iter position, const T &amp;x)" -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#ac3d19d3a42f91618267674f2c236aad9">insert</a> (iter <a class="el" href="fx-0_89_84_2lib_2ofx__sgml_8cpp.html#a4da8008b6f110050513003edf67a2495">position</a>, const T &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert node as previous sibling of node pointed to by position. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a429bbd485078981ef83b59a779d9f947"></a><!-- doxytag: member="tree::insert" ref="a429bbd485078981ef83b59a779d9f947" args="(sibling_iterator position, const T &amp;x)" -->
<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a429bbd485078981ef83b59a779d9f947">insert</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> <a class="el" href="fx-0_89_84_2lib_2ofx__sgml_8cpp.html#a4da8008b6f110050513003edf67a2495">position</a>, const T &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of previous member. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ad66d55d58b48ce0a8d7a5b41abe923d5"></a><!-- doxytag: member="tree::insert_subtree" ref="ad66d55d58b48ce0a8d7a5b41abe923d5" args="(iter position, const iterator_base &amp;subtree)" -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#ad66d55d58b48ce0a8d7a5b41abe923d5">insert_subtree</a> (iter <a class="el" href="fx-0_89_84_2lib_2ofx__sgml_8cpp.html#a4da8008b6f110050513003edf67a2495">position</a>, const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;subtree)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert node (with children) pointed to by subtree as previous sibling of node pointed to by position. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a215ab56bd13f59c661eb2298e373ff3e"></a><!-- doxytag: member="tree::insert_after" ref="a215ab56bd13f59c661eb2298e373ff3e" args="(iter position, const T &amp;x)" -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#a215ab56bd13f59c661eb2298e373ff3e">insert_after</a> (iter <a class="el" href="fx-0_89_84_2lib_2ofx__sgml_8cpp.html#a4da8008b6f110050513003edf67a2495">position</a>, const T &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert node as next sibling of node pointed to by position. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a4885e968c82655ebebea5d0927b7e9f4"></a><!-- doxytag: member="tree::replace" ref="a4885e968c82655ebebea5d0927b7e9f4" args="(iter position, const T &amp;x)" -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#a4885e968c82655ebebea5d0927b7e9f4">replace</a> (iter <a class="el" href="fx-0_89_84_2lib_2ofx__sgml_8cpp.html#a4da8008b6f110050513003edf67a2495">position</a>, const T &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace node at 'position' with other node (keeping same children); 'position' becomes invalid. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a5d2ad4532598f26c84b1ab0ec84a5d62"></a><!-- doxytag: member="tree::replace" ref="a5d2ad4532598f26c84b1ab0ec84a5d62" args="(iter position, const iterator_base &amp;from)" -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#a5d2ad4532598f26c84b1ab0ec84a5d62">replace</a> (iter <a class="el" href="fx-0_89_84_2lib_2ofx__sgml_8cpp.html#a4da8008b6f110050513003edf67a2495">position</a>, const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;from)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace node at 'position' with subtree starting at 'from' (do not erase subtree at 'from'); see above. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc5bef13996f2fd939d83837aa8e090d"></a><!-- doxytag: member="tree::replace" ref="afc5bef13996f2fd939d83837aa8e090d" args="(sibling_iterator orig_begin, sibling_iterator orig_end, sibling_iterator new_begin, sibling_iterator new_end)" -->
<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#afc5bef13996f2fd939d83837aa8e090d">replace</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> orig_begin, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> orig_end, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> new_begin, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> new_end)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace string of siblings (plus their children) with copy of a new string (with children); see above. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a479c8e3f748608a9b9fb91e58e18998c"></a><!-- doxytag: member="tree::flatten" ref="a479c8e3f748608a9b9fb91e58e18998c" args="(iter position)" -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#a479c8e3f748608a9b9fb91e58e18998c">flatten</a> (iter <a class="el" href="fx-0_89_84_2lib_2ofx__sgml_8cpp.html#a4da8008b6f110050513003edf67a2495">position</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Move all children of node at 'position' to be siblings, returns position. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a32b88523e2d5b6c78381b7da9455be5e"></a><!-- doxytag: member="tree::reparent" ref="a32b88523e2d5b6c78381b7da9455be5e" args="(iter position, sibling_iterator begin, sibling_iterator end)" -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#a32b88523e2d5b6c78381b7da9455be5e">reparent</a> (iter <a class="el" href="fx-0_89_84_2lib_2ofx__sgml_8cpp.html#a4da8008b6f110050513003edf67a2495">position</a>, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> begin, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> end)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Move nodes in range to be children of 'position'. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a021a394ff7139df8573e2cb80e6beaa2"></a><!-- doxytag: member="tree::reparent" ref="a021a394ff7139df8573e2cb80e6beaa2" args="(iter position, iter from)" -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#a021a394ff7139df8573e2cb80e6beaa2">reparent</a> (iter <a class="el" href="fx-0_89_84_2lib_2ofx__sgml_8cpp.html#a4da8008b6f110050513003edf67a2495">position</a>, iter from)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Move all child nodes of 'from' to be children of 'position'. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ae7f72ba46cd061f71720c731b4a9bf63"></a><!-- doxytag: member="tree::move_after" ref="ae7f72ba46cd061f71720c731b4a9bf63" args="(iter target, iter source)" -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#ae7f72ba46cd061f71720c731b4a9bf63">move_after</a> (iter target, iter source)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Move 'source' node (plus its children) to become the next sibling of 'target'. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ab45aa15042445a81b13873d3ef4a2e86"></a><!-- doxytag: member="tree::move_before" ref="ab45aa15042445a81b13873d3ef4a2e86" args="(iter target, iter source)" -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#ab45aa15042445a81b13873d3ef4a2e86">move_before</a> (iter target, iter source)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Move 'source' node (plus its children) to become the previous sibling of 'target'. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aa4f8b906b2758eec530e28387b819284"></a><!-- doxytag: member="tree::move_ontop" ref="aa4f8b906b2758eec530e28387b819284" args="(iter target, iter source)" -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#aa4f8b906b2758eec530e28387b819284">move_ontop</a> (iter target, iter source)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Move 'source' node (plus its children) to become the node at 'target' (erasing the node at 'target'). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e3cd901f8f8d8a3da0e1d32e9282db1"></a><!-- doxytag: member="tree::merge" ref="a1e3cd901f8f8d8a3da0e1d32e9282db1" args="(sibling_iterator, sibling_iterator, sibling_iterator, sibling_iterator, bool duplicate_leaves=false)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a1e3cd901f8f8d8a3da0e1d32e9282db1">merge</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>, bool duplicate_leaves=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge with other tree, creating new branches and leaves only if they are not already present. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a498ec42a5eb44cba8bf9ef6e7fd5db9e"></a><!-- doxytag: member="tree::sort" ref="a498ec42a5eb44cba8bf9ef6e7fd5db9e" args="(sibling_iterator from, sibling_iterator to, bool deep=false)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a498ec42a5eb44cba8bf9ef6e7fd5db9e">sort</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> from, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> to, bool deep=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort (std::sort only moves values of nodes, this one moves children as well). <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="af187f42c28a39304649ee41d3464f2ef"></a><!-- doxytag: member="tree::sort" ref="af187f42c28a39304649ee41d3464f2ef" args="(sibling_iterator from, sibling_iterator to, StrictWeakOrdering comp, bool deep=false)" -->
template&lt;class StrictWeakOrdering &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sort</b> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> from, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> to, StrictWeakOrdering comp, bool deep=false)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a59488f63fc6ad997809d971c48ecfc04"></a><!-- doxytag: member="tree::equal" ref="a59488f63fc6ad997809d971c48ecfc04" args="(const iter &amp;one, const iter &amp;two, const iter &amp;three) const " -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#a59488f63fc6ad997809d971c48ecfc04">equal</a> (const iter &amp;one, const iter &amp;two, const iter &amp;three) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two ranges of nodes (compares nodes as well as tree structure). <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a7ce7ff12a68be494b28925b2f7184a29"></a><!-- doxytag: member="tree::equal" ref="a7ce7ff12a68be494b28925b2f7184a29" args="(const iter &amp;one, const iter &amp;two, const iter &amp;three, BinaryPredicate) const " -->
template&lt;typename iter , class BinaryPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>equal</b> (const iter &amp;one, const iter &amp;two, const iter &amp;three, BinaryPredicate) const </td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a6e2e76dfa6f0f51ca6f573d73b0c1b28"></a><!-- doxytag: member="tree::equal_subtree" ref="a6e2e76dfa6f0f51ca6f573d73b0c1b28" args="(const iter &amp;one, const iter &amp;two) const " -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>equal_subtree</b> (const iter &amp;one, const iter &amp;two) const </td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a5e8445150c43058416d16b4846ff0f15"></a><!-- doxytag: member="tree::equal_subtree" ref="a5e8445150c43058416d16b4846ff0f15" args="(const iter &amp;one, const iter &amp;two, BinaryPredicate) const " -->
template&lt;typename iter , class BinaryPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>equal_subtree</b> (const iter &amp;one, const iter &amp;two, BinaryPredicate) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb61bebed6c56eb5641b0b7fab7fe625"></a><!-- doxytag: member="tree::subtree" ref="adb61bebed6c56eb5641b0b7fab7fe625" args="(sibling_iterator from, sibling_iterator to) const " -->
<a class="el" href="classtree.html">tree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#adb61bebed6c56eb5641b0b7fab7fe625">subtree</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> from, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> to) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a new tree formed by the range of siblings plus all their children. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a830cccac50df183c44c6ff83cab5a27f"></a><!-- doxytag: member="tree::subtree" ref="a830cccac50df183c44c6ff83cab5a27f" args="(tree &amp;, sibling_iterator from, sibling_iterator to) const " -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>subtree</b> (<a class="el" href="classtree.html">tree</a> &amp;, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> from, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> to) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae842f9b70235bc2412b3c43bca759448"></a><!-- doxytag: member="tree::swap" ref="ae842f9b70235bc2412b3c43bca759448" args="(sibling_iterator it)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#ae842f9b70235bc2412b3c43bca759448">swap</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> it)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange the node (plus subtree) with its sibling node (do nothing if no sibling present). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a219ff1bfc99f78fd9a2db71f41891523"></a><!-- doxytag: member="tree::size" ref="a219ff1bfc99f78fd9a2db71f41891523" args="() const " -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a219ff1bfc99f78fd9a2db71f41891523">size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the total number of nodes. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9f7fd30c51443d46ca8941d5bc06da2"></a><!-- doxytag: member="tree::empty" ref="ae9f7fd30c51443d46ca8941d5bc06da2" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#ae9f7fd30c51443d46ca8941d5bc06da2">empty</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if tree is empty. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16c66be75ca89c999a9c4a68497b05a1"></a><!-- doxytag: member="tree::depth" ref="a16c66be75ca89c999a9c4a68497b05a1" args="(const iterator_base &amp;) const " -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a16c66be75ca89c999a9c4a68497b05a1">depth</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the depth to the root. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96f82a90a3e21e82f486f325b0cf9faa"></a><!-- doxytag: member="tree::number_of_children" ref="a96f82a90a3e21e82f486f325b0cf9faa" args="(const iterator_base &amp;) const " -->
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a96f82a90a3e21e82f486f325b0cf9faa">number_of_children</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of children of node at position. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3cddce970c4d44af57cf9ec0d7c3d009"></a><!-- doxytag: member="tree::number_of_siblings" ref="a3cddce970c4d44af57cf9ec0d7c3d009" args="(const iterator_base &amp;) const " -->
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a3cddce970c4d44af57cf9ec0d7c3d009">number_of_siblings</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of 'next' siblings of node at iterator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a825e2106781e846bdd8732c117dc21db"></a><!-- doxytag: member="tree::is_in_subtree" ref="a825e2106781e846bdd8732c117dc21db" args="(const iterator_base &amp;position, const iterator_base &amp;begin, const iterator_base &amp;end) const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a825e2106781e846bdd8732c117dc21db">is_in_subtree</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;<a class="el" href="fx-0_89_84_2lib_2ofx__sgml_8cpp.html#a4da8008b6f110050513003edf67a2495">position</a>, const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;begin, const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;end) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether node at position is in the subtrees with root in the range. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9605b028195248894dc8cf506cd256e3"></a><!-- doxytag: member="tree::is_valid" ref="a9605b028195248894dc8cf506cd256e3" args="(const iterator_base &amp;) const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a9605b028195248894dc8cf506cd256e3">is_valid</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the iterator is an 'end' iterator and thus not actually pointing to a node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade5ec1ba55f94165062e50d01ec35d86"></a><!-- doxytag: member="tree::index" ref="ade5ec1ba55f94165062e50d01ec35d86" args="(sibling_iterator it) const " -->
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#ade5ec1ba55f94165062e50d01ec35d86">index</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> it) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the index of a node in the range of siblings to which it belongs. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a446c722c82607f8b3243a9153b665d19"></a><!-- doxytag: member="tree::child" ref="a446c722c82607f8b3243a9153b665d19" args="(const iterator_base &amp;position, unsigned int) const " -->
<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a446c722c82607f8b3243a9153b665d19">child</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;<a class="el" href="fx-0_89_84_2lib_2ofx__sgml_8cpp.html#a4da8008b6f110050513003edf67a2495">position</a>, unsigned int) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of 'index': return the n-th child of the node at position. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5925c012af64fe91a3a5ed39e3ba9d9a"></a><!-- doxytag: member="tree::tree" ref="a5925c012af64fe91a3a5ed39e3ba9d9a" args="(const T &amp;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>tree</b> (const T &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab72378e7a772a82f90d91ef7493f27bc"></a><!-- doxytag: member="tree::tree" ref="ab72378e7a772a82f90d91ef7493f27bc" args="(const iterator_base &amp;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>tree</b> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9e06b40929dfd33a1024bd422beedb6"></a><!-- doxytag: member="tree::tree" ref="ae9e06b40929dfd33a1024bd422beedb6" args="(const tree&lt; T, tree_node_allocator &gt; &amp;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>tree</b> (const <a class="el" href="classtree.html">tree</a>&lt; T, tree_node_allocator &gt; &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9561c0c73b0605f32bf82a026eaf216a"></a><!-- doxytag: member="tree::operator=" ref="a9561c0c73b0605f32bf82a026eaf216a" args="(const tree&lt; T, tree_node_allocator &gt; &amp;)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classtree.html">tree</a>&lt; T, tree_node_allocator &gt; &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb0b39dab780d42d75dfa71a1609462b"></a><!-- doxytag: member="tree::begin" ref="abb0b39dab780d42d75dfa71a1609462b" args="() const " -->
<a class="el" href="classtree_1_1pre__order__iterator.html">pre_order_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#abb0b39dab780d42d75dfa71a1609462b">begin</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator to the beginning of the tree. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac51a8218d988dc75fe0a1a986cbfdd72"></a><!-- doxytag: member="tree::end" ref="ac51a8218d988dc75fe0a1a986cbfdd72" args="() const " -->
<a class="el" href="classtree_1_1pre__order__iterator.html">pre_order_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#ac51a8218d988dc75fe0a1a986cbfdd72">end</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator to the end of the tree. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac589b0b9d7b7bec68232c37de5a7318f"></a><!-- doxytag: member="tree::begin_post" ref="ac589b0b9d7b7bec68232c37de5a7318f" args="() const " -->
<a class="el" href="classtree_1_1post__order__iterator.html">post_order_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#ac589b0b9d7b7bec68232c37de5a7318f">begin_post</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return post-order iterator to the beginning of the tree. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a874c4d85ee7631a996874d32429ec575"></a><!-- doxytag: member="tree::end_post" ref="a874c4d85ee7631a996874d32429ec575" args="() const " -->
<a class="el" href="classtree_1_1post__order__iterator.html">post_order_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a874c4d85ee7631a996874d32429ec575">end_post</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return post-order iterator to the end of the tree. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32efdda22e59c2e627fc8de2ea4b2729"></a><!-- doxytag: member="tree::begin_fixed" ref="a32efdda22e59c2e627fc8de2ea4b2729" args="(const iterator_base &amp;, unsigned int) const " -->
<a class="el" href="classtree_1_1fixed__depth__iterator.html">fixed_depth_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a32efdda22e59c2e627fc8de2ea4b2729">begin_fixed</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;, unsigned int) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return fixed-depth iterator to the first node at a given depth. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4dad5d0de897c6ff3062151e17ecd192"></a><!-- doxytag: member="tree::end_fixed" ref="a4dad5d0de897c6ff3062151e17ecd192" args="(const iterator_base &amp;, unsigned int) const " -->
<a class="el" href="classtree_1_1fixed__depth__iterator.html">fixed_depth_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a4dad5d0de897c6ff3062151e17ecd192">end_fixed</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;, unsigned int) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return fixed-depth iterator to end of the nodes at given depth. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7def49a7fab1b74d30bdf73fe27c3cfd"></a><!-- doxytag: member="tree::begin" ref="a7def49a7fab1b74d30bdf73fe27c3cfd" args="(const iterator_base &amp;) const " -->
<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a7def49a7fab1b74d30bdf73fe27c3cfd">begin</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return sibling iterator to the first child of given node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee5bbcc93836876ebb7a4f85f9d562f3"></a><!-- doxytag: member="tree::end" ref="aee5bbcc93836876ebb7a4f85f9d562f3" args="(const iterator_base &amp;) const " -->
<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#aee5bbcc93836876ebb7a4f85f9d562f3">end</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return sibling iterator to the end of the children of a given node. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aaaaa1622d2d58ecda846640bd8f8bd28"></a><!-- doxytag: member="tree::parent" ref="aaaaa1622d2d58ecda846640bd8f8bd28" args="(iter) const " -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#aaaaa1622d2d58ecda846640bd8f8bd28">parent</a> (iter) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator to the parent of a node. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a6d38ef0b2b73266cbc39ab021482bb50"></a><!-- doxytag: member="tree::previous_sibling" ref="a6d38ef0b2b73266cbc39ab021482bb50" args="(iter) const " -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#a6d38ef0b2b73266cbc39ab021482bb50">previous_sibling</a> (iter) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator to the previous sibling of a node. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a4e3ea50e0949bd05e27ecb9c6b7162ff"></a><!-- doxytag: member="tree::next_sibling" ref="a4e3ea50e0949bd05e27ecb9c6b7162ff" args="(iter) const " -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#a4e3ea50e0949bd05e27ecb9c6b7162ff">next_sibling</a> (iter) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator to the next sibling of a node. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ace3b299e157ec177230a0144771b2a7e"></a><!-- doxytag: member="tree::next_at_same_depth" ref="ace3b299e157ec177230a0144771b2a7e" args="(iter) const " -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#ace3b299e157ec177230a0144771b2a7e">next_at_same_depth</a> (iter) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator to the next node at a given depth. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8cf6dfe17504abfc0ffabb5a4ba9d0a"></a><!-- doxytag: member="tree::clear" ref="aa8cf6dfe17504abfc0ffabb5a4ba9d0a" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#aa8cf6dfe17504abfc0ffabb5a4ba9d0a">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all nodes of the tree. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a3eb424c89446ae17a747d2aca2cdda4b"></a><!-- doxytag: member="tree::erase" ref="a3eb424c89446ae17a747d2aca2cdda4b" args="(iter)" -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#a3eb424c89446ae17a747d2aca2cdda4b">erase</a> (iter)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase element at position pointed to by iterator, return incremented iterator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05d5fd71c206efc8ac30df5cd46176bc"></a><!-- doxytag: member="tree::erase_children" ref="a05d5fd71c206efc8ac30df5cd46176bc" args="(const iterator_base &amp;)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a05d5fd71c206efc8ac30df5cd46176bc">erase_children</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase all children of the node pointed to by iterator. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a8d68e95f5088d48cb54fd6ae381729f0"></a><!-- doxytag: member="tree::append_child" ref="a8d68e95f5088d48cb54fd6ae381729f0" args="(iter position)" -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#a8d68e95f5088d48cb54fd6ae381729f0">append_child</a> (iter <a class="el" href="fx-0_89_84_2lib_2ofx__sgml_8cpp.html#a4da8008b6f110050513003edf67a2495">position</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert empty node as last child of node pointed to by position. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a9318fa77c4e10ec0a9a26a0d08f182a2"></a><!-- doxytag: member="tree::append_child" ref="a9318fa77c4e10ec0a9a26a0d08f182a2" args="(iter position, const T &amp;x)" -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#a9318fa77c4e10ec0a9a26a0d08f182a2">append_child</a> (iter <a class="el" href="fx-0_89_84_2lib_2ofx__sgml_8cpp.html#a4da8008b6f110050513003edf67a2495">position</a>, const T &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert node as last child of node pointed to by position. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a1fb4734b783fed4a66c24130af67316e"></a><!-- doxytag: member="tree::append_child" ref="a1fb4734b783fed4a66c24130af67316e" args="(iter position, iter other_position)" -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#a1fb4734b783fed4a66c24130af67316e">append_child</a> (iter <a class="el" href="fx-0_89_84_2lib_2ofx__sgml_8cpp.html#a4da8008b6f110050513003edf67a2495">position</a>, iter other_position)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the node (plus its children) at other_position as a child of position. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a92ab22e0a98d8899c0d1b6c9d0a85465"></a><!-- doxytag: member="tree::append_children" ref="a92ab22e0a98d8899c0d1b6c9d0a85465" args="(iter position, sibling_iterator from, sibling_iterator to)" -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#a92ab22e0a98d8899c0d1b6c9d0a85465">append_children</a> (iter <a class="el" href="fx-0_89_84_2lib_2ofx__sgml_8cpp.html#a4da8008b6f110050513003edf67a2495">position</a>, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> from, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> to)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the nodes in the from-to range (plus their children) as children of position. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16e33d0c3cd419a9fc8fd14e8d1a0768"></a><!-- doxytag: member="tree::set_head" ref="a16e33d0c3cd419a9fc8fd14e8d1a0768" args="(const T &amp;x)" -->
<a class="el" href="classtree_1_1pre__order__iterator.html">pre_order_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a16e33d0c3cd419a9fc8fd14e8d1a0768">set_head</a> (const T &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand to insert topmost node in otherwise empty tree. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ac3d19d3a42f91618267674f2c236aad9"></a><!-- doxytag: member="tree::insert" ref="ac3d19d3a42f91618267674f2c236aad9" args="(iter position, const T &amp;x)" -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#ac3d19d3a42f91618267674f2c236aad9">insert</a> (iter <a class="el" href="fx-0_89_84_2lib_2ofx__sgml_8cpp.html#a4da8008b6f110050513003edf67a2495">position</a>, const T &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert node as previous sibling of node pointed to by position. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a228da1f727711e92bc8dd64b10f7dfff"></a><!-- doxytag: member="tree::insert" ref="a228da1f727711e92bc8dd64b10f7dfff" args="(sibling_iterator position, const T &amp;x)" -->
<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a228da1f727711e92bc8dd64b10f7dfff">insert</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> <a class="el" href="fx-0_89_84_2lib_2ofx__sgml_8cpp.html#a4da8008b6f110050513003edf67a2495">position</a>, const T &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of previous member. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ad66d55d58b48ce0a8d7a5b41abe923d5"></a><!-- doxytag: member="tree::insert_subtree" ref="ad66d55d58b48ce0a8d7a5b41abe923d5" args="(iter position, const iterator_base &amp;subtree)" -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#ad66d55d58b48ce0a8d7a5b41abe923d5">insert_subtree</a> (iter <a class="el" href="fx-0_89_84_2lib_2ofx__sgml_8cpp.html#a4da8008b6f110050513003edf67a2495">position</a>, const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;subtree)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert node (with children) pointed to by subtree as previous sibling of node pointed to by position. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a215ab56bd13f59c661eb2298e373ff3e"></a><!-- doxytag: member="tree::insert_after" ref="a215ab56bd13f59c661eb2298e373ff3e" args="(iter position, const T &amp;x)" -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#a215ab56bd13f59c661eb2298e373ff3e">insert_after</a> (iter <a class="el" href="fx-0_89_84_2lib_2ofx__sgml_8cpp.html#a4da8008b6f110050513003edf67a2495">position</a>, const T &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert node as next sibling of node pointed to by position. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a4885e968c82655ebebea5d0927b7e9f4"></a><!-- doxytag: member="tree::replace" ref="a4885e968c82655ebebea5d0927b7e9f4" args="(iter position, const T &amp;x)" -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#a4885e968c82655ebebea5d0927b7e9f4">replace</a> (iter <a class="el" href="fx-0_89_84_2lib_2ofx__sgml_8cpp.html#a4da8008b6f110050513003edf67a2495">position</a>, const T &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace node at 'position' with other node (keeping same children); 'position' becomes invalid. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a5d2ad4532598f26c84b1ab0ec84a5d62"></a><!-- doxytag: member="tree::replace" ref="a5d2ad4532598f26c84b1ab0ec84a5d62" args="(iter position, const iterator_base &amp;from)" -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#a5d2ad4532598f26c84b1ab0ec84a5d62">replace</a> (iter <a class="el" href="fx-0_89_84_2lib_2ofx__sgml_8cpp.html#a4da8008b6f110050513003edf67a2495">position</a>, const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;from)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace node at 'position' with subtree starting at 'from' (do not erase subtree at 'from'); see above. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a246ce66bdbc54066ff9b3f47df9adde3"></a><!-- doxytag: member="tree::replace" ref="a246ce66bdbc54066ff9b3f47df9adde3" args="(sibling_iterator orig_begin, sibling_iterator orig_end, sibling_iterator new_begin, sibling_iterator new_end)" -->
<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a246ce66bdbc54066ff9b3f47df9adde3">replace</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> orig_begin, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> orig_end, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> new_begin, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> new_end)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace string of siblings (plus their children) with copy of a new string (with children); see above. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a479c8e3f748608a9b9fb91e58e18998c"></a><!-- doxytag: member="tree::flatten" ref="a479c8e3f748608a9b9fb91e58e18998c" args="(iter position)" -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#a479c8e3f748608a9b9fb91e58e18998c">flatten</a> (iter <a class="el" href="fx-0_89_84_2lib_2ofx__sgml_8cpp.html#a4da8008b6f110050513003edf67a2495">position</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Move all children of node at 'position' to be siblings, returns position. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a32b88523e2d5b6c78381b7da9455be5e"></a><!-- doxytag: member="tree::reparent" ref="a32b88523e2d5b6c78381b7da9455be5e" args="(iter position, sibling_iterator begin, sibling_iterator end)" -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#a32b88523e2d5b6c78381b7da9455be5e">reparent</a> (iter <a class="el" href="fx-0_89_84_2lib_2ofx__sgml_8cpp.html#a4da8008b6f110050513003edf67a2495">position</a>, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> begin, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> end)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Move nodes in range to be children of 'position'. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a021a394ff7139df8573e2cb80e6beaa2"></a><!-- doxytag: member="tree::reparent" ref="a021a394ff7139df8573e2cb80e6beaa2" args="(iter position, iter from)" -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#a021a394ff7139df8573e2cb80e6beaa2">reparent</a> (iter <a class="el" href="fx-0_89_84_2lib_2ofx__sgml_8cpp.html#a4da8008b6f110050513003edf67a2495">position</a>, iter from)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Move all child nodes of 'from' to be children of 'position'. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ae7f72ba46cd061f71720c731b4a9bf63"></a><!-- doxytag: member="tree::move_after" ref="ae7f72ba46cd061f71720c731b4a9bf63" args="(iter target, iter source)" -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#ae7f72ba46cd061f71720c731b4a9bf63">move_after</a> (iter target, iter source)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Move 'source' node (plus its children) to become the next sibling of 'target'. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ab45aa15042445a81b13873d3ef4a2e86"></a><!-- doxytag: member="tree::move_before" ref="ab45aa15042445a81b13873d3ef4a2e86" args="(iter target, iter source)" -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#ab45aa15042445a81b13873d3ef4a2e86">move_before</a> (iter target, iter source)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Move 'source' node (plus its children) to become the previous sibling of 'target'. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aa4f8b906b2758eec530e28387b819284"></a><!-- doxytag: member="tree::move_ontop" ref="aa4f8b906b2758eec530e28387b819284" args="(iter target, iter source)" -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#aa4f8b906b2758eec530e28387b819284">move_ontop</a> (iter target, iter source)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Move 'source' node (plus its children) to become the node at 'target' (erasing the node at 'target'). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e3cd901f8f8d8a3da0e1d32e9282db1"></a><!-- doxytag: member="tree::merge" ref="a1e3cd901f8f8d8a3da0e1d32e9282db1" args="(sibling_iterator, sibling_iterator, sibling_iterator, sibling_iterator, bool duplicate_leaves=false)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a1e3cd901f8f8d8a3da0e1d32e9282db1">merge</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>, bool duplicate_leaves=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge with other tree, creating new branches and leaves only if they are not already present. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a498ec42a5eb44cba8bf9ef6e7fd5db9e"></a><!-- doxytag: member="tree::sort" ref="a498ec42a5eb44cba8bf9ef6e7fd5db9e" args="(sibling_iterator from, sibling_iterator to, bool deep=false)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a498ec42a5eb44cba8bf9ef6e7fd5db9e">sort</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> from, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> to, bool deep=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort (std::sort only moves values of nodes, this one moves children as well). <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="af187f42c28a39304649ee41d3464f2ef"></a><!-- doxytag: member="tree::sort" ref="af187f42c28a39304649ee41d3464f2ef" args="(sibling_iterator from, sibling_iterator to, StrictWeakOrdering comp, bool deep=false)" -->
template&lt;class StrictWeakOrdering &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sort</b> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> from, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> to, StrictWeakOrdering comp, bool deep=false)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a59488f63fc6ad997809d971c48ecfc04"></a><!-- doxytag: member="tree::equal" ref="a59488f63fc6ad997809d971c48ecfc04" args="(const iter &amp;one, const iter &amp;two, const iter &amp;three) const " -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#a59488f63fc6ad997809d971c48ecfc04">equal</a> (const iter &amp;one, const iter &amp;two, const iter &amp;three) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two ranges of nodes (compares nodes as well as tree structure). <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a7ce7ff12a68be494b28925b2f7184a29"></a><!-- doxytag: member="tree::equal" ref="a7ce7ff12a68be494b28925b2f7184a29" args="(const iter &amp;one, const iter &amp;two, const iter &amp;three, BinaryPredicate) const " -->
template&lt;typename iter , class BinaryPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>equal</b> (const iter &amp;one, const iter &amp;two, const iter &amp;three, BinaryPredicate) const </td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a6e2e76dfa6f0f51ca6f573d73b0c1b28"></a><!-- doxytag: member="tree::equal_subtree" ref="a6e2e76dfa6f0f51ca6f573d73b0c1b28" args="(const iter &amp;one, const iter &amp;two) const " -->
template&lt;typename iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>equal_subtree</b> (const iter &amp;one, const iter &amp;two) const </td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a5e8445150c43058416d16b4846ff0f15"></a><!-- doxytag: member="tree::equal_subtree" ref="a5e8445150c43058416d16b4846ff0f15" args="(const iter &amp;one, const iter &amp;two, BinaryPredicate) const " -->
template&lt;typename iter , class BinaryPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>equal_subtree</b> (const iter &amp;one, const iter &amp;two, BinaryPredicate) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5948cb430e05082d3c7ee9e89b726af5"></a><!-- doxytag: member="tree::subtree" ref="a5948cb430e05082d3c7ee9e89b726af5" args="(sibling_iterator from, sibling_iterator to) const " -->
<a class="el" href="classtree.html">tree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a5948cb430e05082d3c7ee9e89b726af5">subtree</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> from, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> to) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a new tree formed by the range of siblings plus all their children. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a830cccac50df183c44c6ff83cab5a27f"></a><!-- doxytag: member="tree::subtree" ref="a830cccac50df183c44c6ff83cab5a27f" args="(tree &amp;, sibling_iterator from, sibling_iterator to) const " -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>subtree</b> (<a class="el" href="classtree.html">tree</a> &amp;, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> from, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> to) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae842f9b70235bc2412b3c43bca759448"></a><!-- doxytag: member="tree::swap" ref="ae842f9b70235bc2412b3c43bca759448" args="(sibling_iterator it)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#ae842f9b70235bc2412b3c43bca759448">swap</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> it)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange the node (plus subtree) with its sibling node (do nothing if no sibling present). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a219ff1bfc99f78fd9a2db71f41891523"></a><!-- doxytag: member="tree::size" ref="a219ff1bfc99f78fd9a2db71f41891523" args="() const " -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a219ff1bfc99f78fd9a2db71f41891523">size</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the total number of nodes. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9f7fd30c51443d46ca8941d5bc06da2"></a><!-- doxytag: member="tree::empty" ref="ae9f7fd30c51443d46ca8941d5bc06da2" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#ae9f7fd30c51443d46ca8941d5bc06da2">empty</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if tree is empty. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16c66be75ca89c999a9c4a68497b05a1"></a><!-- doxytag: member="tree::depth" ref="a16c66be75ca89c999a9c4a68497b05a1" args="(const iterator_base &amp;) const " -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a16c66be75ca89c999a9c4a68497b05a1">depth</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the depth to the root. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96f82a90a3e21e82f486f325b0cf9faa"></a><!-- doxytag: member="tree::number_of_children" ref="a96f82a90a3e21e82f486f325b0cf9faa" args="(const iterator_base &amp;) const " -->
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a96f82a90a3e21e82f486f325b0cf9faa">number_of_children</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of children of node at position. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3cddce970c4d44af57cf9ec0d7c3d009"></a><!-- doxytag: member="tree::number_of_siblings" ref="a3cddce970c4d44af57cf9ec0d7c3d009" args="(const iterator_base &amp;) const " -->
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a3cddce970c4d44af57cf9ec0d7c3d009">number_of_siblings</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of 'next' siblings of node at iterator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a825e2106781e846bdd8732c117dc21db"></a><!-- doxytag: member="tree::is_in_subtree" ref="a825e2106781e846bdd8732c117dc21db" args="(const iterator_base &amp;position, const iterator_base &amp;begin, const iterator_base &amp;end) const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a825e2106781e846bdd8732c117dc21db">is_in_subtree</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;<a class="el" href="fx-0_89_84_2lib_2ofx__sgml_8cpp.html#a4da8008b6f110050513003edf67a2495">position</a>, const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;begin, const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;end) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether node at position is in the subtrees with root in the range. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9605b028195248894dc8cf506cd256e3"></a><!-- doxytag: member="tree::is_valid" ref="a9605b028195248894dc8cf506cd256e3" args="(const iterator_base &amp;) const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a9605b028195248894dc8cf506cd256e3">is_valid</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the iterator is an 'end' iterator and thus not actually pointing to a node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade5ec1ba55f94165062e50d01ec35d86"></a><!-- doxytag: member="tree::index" ref="ade5ec1ba55f94165062e50d01ec35d86" args="(sibling_iterator it) const " -->
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#ade5ec1ba55f94165062e50d01ec35d86">index</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> it) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the index of a node in the range of siblings to which it belongs. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa614f997d8c45de7a5ea25733ac036be"></a><!-- doxytag: member="tree::child" ref="aa614f997d8c45de7a5ea25733ac036be" args="(const iterator_base &amp;position, unsigned int) const " -->
<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#aa614f997d8c45de7a5ea25733ac036be">child</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;<a class="el" href="fx-0_89_84_2lib_2ofx__sgml_8cpp.html#a4da8008b6f110050513003edf67a2495">position</a>, unsigned int) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of 'index': return the n-th child of the node at position. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95a5503db9f7a428248a0b31afd95b38"></a><!-- doxytag: member="tree::head" ref="a95a5503db9f7a428248a0b31afd95b38" args="" -->
<a class="el" href="classtree__node__.html">tree_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>head</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1dbb80115ba483e37d081a2256c239b"></a><!-- doxytag: member="tree::feet" ref="ae1dbb80115ba483e37d081a2256c239b" args="" -->
<a class="el" href="classtree__node__.html">tree_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>feet</b></td></tr>
<tr><td colspan="2"><h2><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a672d078d87ae97c58b732a940d7b8ca8"></a><!-- doxytag: member="tree::tree_node" ref="a672d078d87ae97c58b732a940d7b8ca8" args="" -->
typedef <a class="el" href="classtree__node__.html">tree_node_</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tree_node</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a672d078d87ae97c58b732a940d7b8ca8"></a><!-- doxytag: member="tree::tree_node" ref="a672d078d87ae97c58b732a940d7b8ca8" args="" -->
typedef <a class="el" href="classtree__node__.html">tree_node_</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tree_node</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class tree_node_allocator = std::allocator&lt;tree_node_&lt;T&gt; &gt;&gt;<br/>
 class tree&lt; T, tree_node_allocator &gt;</h3>


<p>Definition at line <a class="el" href="tree_8hh_source.html#l00105">105</a> of file <a class="el" href="tree_8hh_source.html">tree.hh</a>.</p>
</div><hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="tree_8hh_source.html">tree.hh</a></li>
<li><a class="el" href="fx-0_89_84_2lib_2tree_8hh_source.html">fx-0.9.4/lib/tree.hh</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="classtree.html">tree</a>      </li>
      <li class="footer">Generated on Mon Apr 18 2011 18:09:44 for LibOFX by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
