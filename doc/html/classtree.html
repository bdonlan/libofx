<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>LibOFX: tree&lt; T, tree_node_allocator &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
  </ul>
</div>
<h1>tree&lt; T, tree_node_allocator &gt; Class Template Reference</h1><!-- doxytag: class="tree" --><hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class T, class tree_node_allocator = std::allocator&lt;tree_node_&lt;T&gt; &gt;&gt;<br>
 class tree&lt; T, tree_node_allocator &gt;</h3>


<p>Definition at line <a class="el" href="tree_8hh-source.html#l00103">103</a> of file <a class="el" href="tree_8hh-source.html">tree.hh</a>.</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1e7bcd21e7420f7922a1bca79080acfa"></a><!-- doxytag: member="tree::value_type" ref="1e7bcd21e7420f7922a1bca79080acfa" args="" -->
typedef T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#1e7bcd21e7420f7922a1bca79080acfa">value_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Value of the data stored at a node. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2079982538b88d21fe1ccea34fe7ce0e"></a><!-- doxytag: member="tree::iterator" ref="2079982538b88d21fe1ccea34fe7ce0e" args="" -->
typedef <br>
<a class="el" href="classtree_1_1pre__order__iterator.html">pre_order_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#2079982538b88d21fe1ccea34fe7ce0e">iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The default iterator type throughout the <a class="el" href="classtree.html">tree</a> class. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1e7bcd21e7420f7922a1bca79080acfa"></a><!-- doxytag: member="tree::value_type" ref="1e7bcd21e7420f7922a1bca79080acfa" args="" -->
typedef T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#1e7bcd21e7420f7922a1bca79080acfa">value_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Value of the data stored at a node. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2079982538b88d21fe1ccea34fe7ce0e"></a><!-- doxytag: member="tree::iterator" ref="2079982538b88d21fe1ccea34fe7ce0e" args="" -->
typedef <br>
<a class="el" href="classtree_1_1pre__order__iterator.html">pre_order_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#2079982538b88d21fe1ccea34fe7ce0e">iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The default iterator type throughout the <a class="el" href="classtree.html">tree</a> class. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1e7bcd21e7420f7922a1bca79080acfa"></a><!-- doxytag: member="tree::value_type" ref="1e7bcd21e7420f7922a1bca79080acfa" args="" -->
typedef T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#1e7bcd21e7420f7922a1bca79080acfa">value_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Value of the data stored at a node. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2079982538b88d21fe1ccea34fe7ce0e"></a><!-- doxytag: member="tree::iterator" ref="2079982538b88d21fe1ccea34fe7ce0e" args="" -->
typedef <br>
<a class="el" href="classtree_1_1pre__order__iterator.html">pre_order_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#2079982538b88d21fe1ccea34fe7ce0e">iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The default iterator type throughout the <a class="el" href="classtree.html">tree</a> class. <br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a064a1d9dceac9b918c5247919a4a325"></a><!-- doxytag: member="tree::tree" ref="a064a1d9dceac9b918c5247919a4a325" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a064a1d9dceac9b918c5247919a4a325">tree</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5925c012af64fe91a3a5ed39e3ba9d9a"></a><!-- doxytag: member="tree::tree" ref="5925c012af64fe91a3a5ed39e3ba9d9a" args="(const T &amp;)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#5925c012af64fe91a3a5ed39e3ba9d9a">tree</a> (const T &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b72378e7a772a82f90d91ef7493f27bc"></a><!-- doxytag: member="tree::tree" ref="b72378e7a772a82f90d91ef7493f27bc" args="(const iterator_base &amp;)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#b72378e7a772a82f90d91ef7493f27bc">tree</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e9e06b40929dfd33a1024bd422beedb6"></a><!-- doxytag: member="tree::tree" ref="e9e06b40929dfd33a1024bd422beedb6" args="(const tree&lt; T, tree_node_allocator &gt; &amp;)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#e9e06b40929dfd33a1024bd422beedb6">tree</a> (const <a class="el" href="classtree.html">tree</a>&lt; T, tree_node_allocator &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f0169b515c95f4299fd2d984137b7868"></a><!-- doxytag: member="tree::~tree" ref="f0169b515c95f4299fd2d984137b7868" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#f0169b515c95f4299fd2d984137b7868">~tree</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9561c0c73b0605f32bf82a026eaf216a"></a><!-- doxytag: member="tree::operator=" ref="9561c0c73b0605f32bf82a026eaf216a" args="(const tree&lt; T, tree_node_allocator &gt; &amp;)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#9561c0c73b0605f32bf82a026eaf216a">operator=</a> (const <a class="el" href="classtree.html">tree</a>&lt; T, tree_node_allocator &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="76b3a629c0208d5ae5b4ffcd4492e05e"></a><!-- doxytag: member="tree::begin" ref="76b3a629c0208d5ae5b4ffcd4492e05e" args="() const " -->
<a class="el" href="classtree_1_1pre__order__iterator.html">pre_order_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#76b3a629c0208d5ae5b4ffcd4492e05e">begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return iterator to the beginning of the <a class="el" href="classtree.html">tree</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0d09fe9fd34fbfc9c9e4e28cb694448e"></a><!-- doxytag: member="tree::end" ref="0d09fe9fd34fbfc9c9e4e28cb694448e" args="() const " -->
<a class="el" href="classtree_1_1pre__order__iterator.html">pre_order_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#0d09fe9fd34fbfc9c9e4e28cb694448e">end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return iterator to the end of the <a class="el" href="classtree.html">tree</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="73c673d39fe46db7ca4e1533841cdbc0"></a><!-- doxytag: member="tree::begin_post" ref="73c673d39fe46db7ca4e1533841cdbc0" args="() const " -->
<a class="el" href="classtree_1_1post__order__iterator.html">post_order_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#73c673d39fe46db7ca4e1533841cdbc0">begin_post</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return post-order iterator to the beginning of the <a class="el" href="classtree.html">tree</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d339ab550fc2718e84506e91960a177f"></a><!-- doxytag: member="tree::end_post" ref="d339ab550fc2718e84506e91960a177f" args="() const " -->
<a class="el" href="classtree_1_1post__order__iterator.html">post_order_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#d339ab550fc2718e84506e91960a177f">end_post</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return post-order iterator to the end of the <a class="el" href="classtree.html">tree</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3e7ee34b9582cb6f0bd5b25f501a1057"></a><!-- doxytag: member="tree::begin_fixed" ref="3e7ee34b9582cb6f0bd5b25f501a1057" args="(const iterator_base &amp;, unsigned int) const " -->
<a class="el" href="classtree_1_1fixed__depth__iterator.html">fixed_depth_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#3e7ee34b9582cb6f0bd5b25f501a1057">begin_fixed</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;, unsigned int) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return fixed-depth iterator to the first node at a given depth. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bab26c0edd25cc836ed768e32c034165"></a><!-- doxytag: member="tree::end_fixed" ref="bab26c0edd25cc836ed768e32c034165" args="(const iterator_base &amp;, unsigned int) const " -->
<a class="el" href="classtree_1_1fixed__depth__iterator.html">fixed_depth_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#bab26c0edd25cc836ed768e32c034165">end_fixed</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;, unsigned int) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return fixed-depth iterator to end of the nodes at given depth. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a784ffa6dec85f52754dde8bd6a99aeb"></a><!-- doxytag: member="tree::begin" ref="a784ffa6dec85f52754dde8bd6a99aeb" args="(const iterator_base &amp;) const " -->
<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a784ffa6dec85f52754dde8bd6a99aeb">begin</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return sibling iterator to the first child of given node. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a6aa8b0c6af0f50bfc86592847759127"></a><!-- doxytag: member="tree::end" ref="a6aa8b0c6af0f50bfc86592847759127" args="(const iterator_base &amp;) const " -->
<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a6aa8b0c6af0f50bfc86592847759127">end</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return sibling iterator to the end of the children of a given node. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="aaaa1622d2d58ecda846640bd8f8bd28"></a><!-- doxytag: member="tree::parent" ref="aaaa1622d2d58ecda846640bd8f8bd28" args="(iter) const " -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#aaaa1622d2d58ecda846640bd8f8bd28">parent</a> (iter) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return iterator to the parent of a node. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="6d38ef0b2b73266cbc39ab021482bb50"></a><!-- doxytag: member="tree::previous_sibling" ref="6d38ef0b2b73266cbc39ab021482bb50" args="(iter) const " -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#6d38ef0b2b73266cbc39ab021482bb50">previous_sibling</a> (iter) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return iterator to the previous sibling of a node. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="4e3ea50e0949bd05e27ecb9c6b7162ff"></a><!-- doxytag: member="tree::next_sibling" ref="4e3ea50e0949bd05e27ecb9c6b7162ff" args="(iter) const " -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#4e3ea50e0949bd05e27ecb9c6b7162ff">next_sibling</a> (iter) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return iterator to the next sibling of a node. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ce3b299e157ec177230a0144771b2a7e"></a><!-- doxytag: member="tree::next_at_same_depth" ref="ce3b299e157ec177230a0144771b2a7e" args="(iter) const " -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#ce3b299e157ec177230a0144771b2a7e">next_at_same_depth</a> (iter) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return iterator to the next node at a given depth. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a8cf6dfe17504abfc0ffabb5a4ba9d0a"></a><!-- doxytag: member="tree::clear" ref="a8cf6dfe17504abfc0ffabb5a4ba9d0a" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a8cf6dfe17504abfc0ffabb5a4ba9d0a">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase all nodes of the <a class="el" href="classtree.html">tree</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="3eb424c89446ae17a747d2aca2cdda4b"></a><!-- doxytag: member="tree::erase" ref="3eb424c89446ae17a747d2aca2cdda4b" args="(iter)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#3eb424c89446ae17a747d2aca2cdda4b">erase</a> (iter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase element at position pointed to by iterator, return incremented iterator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="05d5fd71c206efc8ac30df5cd46176bc"></a><!-- doxytag: member="tree::erase_children" ref="05d5fd71c206efc8ac30df5cd46176bc" args="(const iterator_base &amp;)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#05d5fd71c206efc8ac30df5cd46176bc">erase_children</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase all children of the node pointed to by iterator. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="8d68e95f5088d48cb54fd6ae381729f0"></a><!-- doxytag: member="tree::append_child" ref="8d68e95f5088d48cb54fd6ae381729f0" args="(iter position)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#8d68e95f5088d48cb54fd6ae381729f0">append_child</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert empty node as last child of node pointed to by position. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="9318fa77c4e10ec0a9a26a0d08f182a2"></a><!-- doxytag: member="tree::append_child" ref="9318fa77c4e10ec0a9a26a0d08f182a2" args="(iter position, const T &amp;x)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#9318fa77c4e10ec0a9a26a0d08f182a2">append_child</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, const T &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert node as last child of node pointed to by position. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="1fb4734b783fed4a66c24130af67316e"></a><!-- doxytag: member="tree::append_child" ref="1fb4734b783fed4a66c24130af67316e" args="(iter position, iter other_position)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#1fb4734b783fed4a66c24130af67316e">append_child</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, iter other_position)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append the node (plus its children) at other_position as a child of position. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="92ab22e0a98d8899c0d1b6c9d0a85465"></a><!-- doxytag: member="tree::append_children" ref="92ab22e0a98d8899c0d1b6c9d0a85465" args="(iter position, sibling_iterator from, sibling_iterator to)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#92ab22e0a98d8899c0d1b6c9d0a85465">append_children</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> from, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> to)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append the nodes in the from-to range (plus their children) as children of position. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f11d736ea971ab93651350161f5a7535"></a><!-- doxytag: member="tree::set_head" ref="f11d736ea971ab93651350161f5a7535" args="(const T &amp;x)" -->
<a class="el" href="classtree_1_1pre__order__iterator.html">pre_order_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#f11d736ea971ab93651350161f5a7535">set_head</a> (const T &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Short-hand to insert topmost node in otherwise empty <a class="el" href="classtree.html">tree</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="c3d19d3a42f91618267674f2c236aad9"></a><!-- doxytag: member="tree::insert" ref="c3d19d3a42f91618267674f2c236aad9" args="(iter position, const T &amp;x)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#c3d19d3a42f91618267674f2c236aad9">insert</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, const T &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert node as previous sibling of node pointed to by position. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="429bbd485078981ef83b59a779d9f947"></a><!-- doxytag: member="tree::insert" ref="429bbd485078981ef83b59a779d9f947" args="(sibling_iterator position, const T &amp;x)" -->
<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#429bbd485078981ef83b59a779d9f947">insert</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, const T &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialisation of previous member. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="d66d55d58b48ce0a8d7a5b41abe923d5"></a><!-- doxytag: member="tree::insert_subtree" ref="d66d55d58b48ce0a8d7a5b41abe923d5" args="(iter position, const iterator_base &amp;subtree)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#d66d55d58b48ce0a8d7a5b41abe923d5">insert_subtree</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;subtree)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert node (with children) pointed to by subtree as previous sibling of node pointed to by position. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="215ab56bd13f59c661eb2298e373ff3e"></a><!-- doxytag: member="tree::insert_after" ref="215ab56bd13f59c661eb2298e373ff3e" args="(iter position, const T &amp;x)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#215ab56bd13f59c661eb2298e373ff3e">insert_after</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, const T &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert node as next sibling of node pointed to by position. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="4885e968c82655ebebea5d0927b7e9f4"></a><!-- doxytag: member="tree::replace" ref="4885e968c82655ebebea5d0927b7e9f4" args="(iter position, const T &amp;x)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#4885e968c82655ebebea5d0927b7e9f4">replace</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, const T &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace node at 'position' with other node (keeping same children); 'position' becomes invalid. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="5d2ad4532598f26c84b1ab0ec84a5d62"></a><!-- doxytag: member="tree::replace" ref="5d2ad4532598f26c84b1ab0ec84a5d62" args="(iter position, const iterator_base &amp;from)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#5d2ad4532598f26c84b1ab0ec84a5d62">replace</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;from)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace node at 'position' with subtree starting at 'from' (do not erase subtree at 'from'); see above. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fc5bef13996f2fd939d83837aa8e090d"></a><!-- doxytag: member="tree::replace" ref="fc5bef13996f2fd939d83837aa8e090d" args="(sibling_iterator orig_begin, sibling_iterator orig_end, sibling_iterator new_begin, sibling_iterator new_end)" -->
<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#fc5bef13996f2fd939d83837aa8e090d">replace</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> orig_begin, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> orig_end, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> new_begin, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> new_end)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace string of siblings (plus their children) with copy of a new string (with children); see above. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="479c8e3f748608a9b9fb91e58e18998c"></a><!-- doxytag: member="tree::flatten" ref="479c8e3f748608a9b9fb91e58e18998c" args="(iter position)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#479c8e3f748608a9b9fb91e58e18998c">flatten</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move all children of node at 'position' to be siblings, returns position. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="32b88523e2d5b6c78381b7da9455be5e"></a><!-- doxytag: member="tree::reparent" ref="32b88523e2d5b6c78381b7da9455be5e" args="(iter position, sibling_iterator begin, sibling_iterator end)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#32b88523e2d5b6c78381b7da9455be5e">reparent</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> begin, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> end)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move nodes in range to be children of 'position'. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="021a394ff7139df8573e2cb80e6beaa2"></a><!-- doxytag: member="tree::reparent" ref="021a394ff7139df8573e2cb80e6beaa2" args="(iter position, iter from)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#021a394ff7139df8573e2cb80e6beaa2">reparent</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, iter from)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move all child nodes of 'from' to be children of 'position'. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="e7f72ba46cd061f71720c731b4a9bf63"></a><!-- doxytag: member="tree::move_after" ref="e7f72ba46cd061f71720c731b4a9bf63" args="(iter target, iter source)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#e7f72ba46cd061f71720c731b4a9bf63">move_after</a> (iter target, iter source)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move 'source' node (plus its children) to become the next sibling of 'target'. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="b45aa15042445a81b13873d3ef4a2e86"></a><!-- doxytag: member="tree::move_before" ref="b45aa15042445a81b13873d3ef4a2e86" args="(iter target, iter source)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#b45aa15042445a81b13873d3ef4a2e86">move_before</a> (iter target, iter source)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move 'source' node (plus its children) to become the previous sibling of 'target'. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a4f8b906b2758eec530e28387b819284"></a><!-- doxytag: member="tree::move_ontop" ref="a4f8b906b2758eec530e28387b819284" args="(iter target, iter source)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#a4f8b906b2758eec530e28387b819284">move_ontop</a> (iter target, iter source)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move 'source' node (plus its children) to become the node at 'target' (erasing the node at 'target'). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1e3cd901f8f8d8a3da0e1d32e9282db1"></a><!-- doxytag: member="tree::merge" ref="1e3cd901f8f8d8a3da0e1d32e9282db1" args="(sibling_iterator, sibling_iterator, sibling_iterator, sibling_iterator, bool duplicate_leaves=false)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#1e3cd901f8f8d8a3da0e1d32e9282db1">merge</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>, bool duplicate_leaves=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Merge with other <a class="el" href="classtree.html">tree</a>, creating new branches and leaves only if they are not already present. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="498ec42a5eb44cba8bf9ef6e7fd5db9e"></a><!-- doxytag: member="tree::sort" ref="498ec42a5eb44cba8bf9ef6e7fd5db9e" args="(sibling_iterator from, sibling_iterator to, bool deep=false)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#498ec42a5eb44cba8bf9ef6e7fd5db9e">sort</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> from, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> to, bool deep=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sort (std::sort only moves values of nodes, this one moves children as well). <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="f187f42c28a39304649ee41d3464f2ef"></a><!-- doxytag: member="tree::sort" ref="f187f42c28a39304649ee41d3464f2ef" args="(sibling_iterator from, sibling_iterator to, StrictWeakOrdering comp, bool deep=false)" -->
template&lt;class StrictWeakOrdering&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#f187f42c28a39304649ee41d3464f2ef">sort</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> from, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> to, StrictWeakOrdering comp, bool deep=false)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="59488f63fc6ad997809d971c48ecfc04"></a><!-- doxytag: member="tree::equal" ref="59488f63fc6ad997809d971c48ecfc04" args="(const iter &amp;one, const iter &amp;two, const iter &amp;three) const " -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#59488f63fc6ad997809d971c48ecfc04">equal</a> (const iter &amp;one, const iter &amp;two, const iter &amp;three) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two ranges of nodes (compares nodes as well as <a class="el" href="classtree.html">tree</a> structure). <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="7ce7ff12a68be494b28925b2f7184a29"></a><!-- doxytag: member="tree::equal" ref="7ce7ff12a68be494b28925b2f7184a29" args="(const iter &amp;one, const iter &amp;two, const iter &amp;three, BinaryPredicate) const " -->
template&lt;typename iter, class BinaryPredicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#7ce7ff12a68be494b28925b2f7184a29">equal</a> (const iter &amp;one, const iter &amp;two, const iter &amp;three, BinaryPredicate) const </td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="6e2e76dfa6f0f51ca6f573d73b0c1b28"></a><!-- doxytag: member="tree::equal_subtree" ref="6e2e76dfa6f0f51ca6f573d73b0c1b28" args="(const iter &amp;one, const iter &amp;two) const " -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#6e2e76dfa6f0f51ca6f573d73b0c1b28">equal_subtree</a> (const iter &amp;one, const iter &amp;two) const </td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="5e8445150c43058416d16b4846ff0f15"></a><!-- doxytag: member="tree::equal_subtree" ref="5e8445150c43058416d16b4846ff0f15" args="(const iter &amp;one, const iter &amp;two, BinaryPredicate) const " -->
template&lt;typename iter, class BinaryPredicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#5e8445150c43058416d16b4846ff0f15">equal_subtree</a> (const iter &amp;one, const iter &amp;two, BinaryPredicate) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="db61bebed6c56eb5641b0b7fab7fe625"></a><!-- doxytag: member="tree::subtree" ref="db61bebed6c56eb5641b0b7fab7fe625" args="(sibling_iterator from, sibling_iterator to) const " -->
<a class="el" href="classtree.html">tree</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#db61bebed6c56eb5641b0b7fab7fe625">subtree</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> from, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> to) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract a new <a class="el" href="classtree.html">tree</a> formed by the range of siblings plus all their children. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="830cccac50df183c44c6ff83cab5a27f"></a><!-- doxytag: member="tree::subtree" ref="830cccac50df183c44c6ff83cab5a27f" args="(tree &amp;, sibling_iterator from, sibling_iterator to) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#830cccac50df183c44c6ff83cab5a27f">subtree</a> (<a class="el" href="classtree.html">tree</a> &amp;, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> from, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> to) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e842f9b70235bc2412b3c43bca759448"></a><!-- doxytag: member="tree::swap" ref="e842f9b70235bc2412b3c43bca759448" args="(sibling_iterator it)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#e842f9b70235bc2412b3c43bca759448">swap</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> it)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exchange the node (plus subtree) with its sibling node (do nothing if no sibling present). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="219ff1bfc99f78fd9a2db71f41891523"></a><!-- doxytag: member="tree::size" ref="219ff1bfc99f78fd9a2db71f41891523" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#219ff1bfc99f78fd9a2db71f41891523">size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Count the total number of nodes. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e9f7fd30c51443d46ca8941d5bc06da2"></a><!-- doxytag: member="tree::empty" ref="e9f7fd30c51443d46ca8941d5bc06da2" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#e9f7fd30c51443d46ca8941d5bc06da2">empty</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if <a class="el" href="classtree.html">tree</a> is empty. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="16c66be75ca89c999a9c4a68497b05a1"></a><!-- doxytag: member="tree::depth" ref="16c66be75ca89c999a9c4a68497b05a1" args="(const iterator_base &amp;) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#16c66be75ca89c999a9c4a68497b05a1">depth</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the depth to the root. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="96f82a90a3e21e82f486f325b0cf9faa"></a><!-- doxytag: member="tree::number_of_children" ref="96f82a90a3e21e82f486f325b0cf9faa" args="(const iterator_base &amp;) const " -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#96f82a90a3e21e82f486f325b0cf9faa">number_of_children</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Count the number of children of node at position. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3cddce970c4d44af57cf9ec0d7c3d009"></a><!-- doxytag: member="tree::number_of_siblings" ref="3cddce970c4d44af57cf9ec0d7c3d009" args="(const iterator_base &amp;) const " -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#3cddce970c4d44af57cf9ec0d7c3d009">number_of_siblings</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Count the number of 'next' siblings of node at iterator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="825e2106781e846bdd8732c117dc21db"></a><!-- doxytag: member="tree::is_in_subtree" ref="825e2106781e846bdd8732c117dc21db" args="(const iterator_base &amp;position, const iterator_base &amp;begin, const iterator_base &amp;end) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#825e2106781e846bdd8732c117dc21db">is_in_subtree</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;<a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;begin, const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;end) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine whether node at position is in the subtrees with root in the range. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9605b028195248894dc8cf506cd256e3"></a><!-- doxytag: member="tree::is_valid" ref="9605b028195248894dc8cf506cd256e3" args="(const iterator_base &amp;) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#9605b028195248894dc8cf506cd256e3">is_valid</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine whether the iterator is an 'end' iterator and thus not actually pointing to a node. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="de5ec1ba55f94165062e50d01ec35d86"></a><!-- doxytag: member="tree::index" ref="de5ec1ba55f94165062e50d01ec35d86" args="(sibling_iterator it) const " -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#de5ec1ba55f94165062e50d01ec35d86">index</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> it) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the index of a node in the range of siblings to which it belongs. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="446c722c82607f8b3243a9153b665d19"></a><!-- doxytag: member="tree::child" ref="446c722c82607f8b3243a9153b665d19" args="(const iterator_base &amp;position, unsigned int) const " -->
<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#446c722c82607f8b3243a9153b665d19">child</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;<a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, unsigned int) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inverse of 'index': return the n-th child of the node at position. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5925c012af64fe91a3a5ed39e3ba9d9a"></a><!-- doxytag: member="tree::tree" ref="5925c012af64fe91a3a5ed39e3ba9d9a" args="(const T &amp;)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>tree</b> (const T &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b72378e7a772a82f90d91ef7493f27bc"></a><!-- doxytag: member="tree::tree" ref="b72378e7a772a82f90d91ef7493f27bc" args="(const iterator_base &amp;)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>tree</b> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e9e06b40929dfd33a1024bd422beedb6"></a><!-- doxytag: member="tree::tree" ref="e9e06b40929dfd33a1024bd422beedb6" args="(const tree&lt; T, tree_node_allocator &gt; &amp;)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>tree</b> (const <a class="el" href="classtree.html">tree</a>&lt; T, tree_node_allocator &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9561c0c73b0605f32bf82a026eaf216a"></a><!-- doxytag: member="tree::operator=" ref="9561c0c73b0605f32bf82a026eaf216a" args="(const tree&lt; T, tree_node_allocator &gt; &amp;)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classtree.html">tree</a>&lt; T, tree_node_allocator &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bb0b39dab780d42d75dfa71a1609462b"></a><!-- doxytag: member="tree::begin" ref="bb0b39dab780d42d75dfa71a1609462b" args="() const " -->
<a class="el" href="classtree_1_1pre__order__iterator.html">pre_order_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#bb0b39dab780d42d75dfa71a1609462b">begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return iterator to the beginning of the <a class="el" href="classtree.html">tree</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c51a8218d988dc75fe0a1a986cbfdd72"></a><!-- doxytag: member="tree::end" ref="c51a8218d988dc75fe0a1a986cbfdd72" args="() const " -->
<a class="el" href="classtree_1_1pre__order__iterator.html">pre_order_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#c51a8218d988dc75fe0a1a986cbfdd72">end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return iterator to the end of the <a class="el" href="classtree.html">tree</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c589b0b9d7b7bec68232c37de5a7318f"></a><!-- doxytag: member="tree::begin_post" ref="c589b0b9d7b7bec68232c37de5a7318f" args="() const " -->
<a class="el" href="classtree_1_1post__order__iterator.html">post_order_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#c589b0b9d7b7bec68232c37de5a7318f">begin_post</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return post-order iterator to the beginning of the <a class="el" href="classtree.html">tree</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="874c4d85ee7631a996874d32429ec575"></a><!-- doxytag: member="tree::end_post" ref="874c4d85ee7631a996874d32429ec575" args="() const " -->
<a class="el" href="classtree_1_1post__order__iterator.html">post_order_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#874c4d85ee7631a996874d32429ec575">end_post</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return post-order iterator to the end of the <a class="el" href="classtree.html">tree</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="32efdda22e59c2e627fc8de2ea4b2729"></a><!-- doxytag: member="tree::begin_fixed" ref="32efdda22e59c2e627fc8de2ea4b2729" args="(const iterator_base &amp;, unsigned int) const " -->
<a class="el" href="classtree_1_1fixed__depth__iterator.html">fixed_depth_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#32efdda22e59c2e627fc8de2ea4b2729">begin_fixed</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;, unsigned int) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return fixed-depth iterator to the first node at a given depth. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4dad5d0de897c6ff3062151e17ecd192"></a><!-- doxytag: member="tree::end_fixed" ref="4dad5d0de897c6ff3062151e17ecd192" args="(const iterator_base &amp;, unsigned int) const " -->
<a class="el" href="classtree_1_1fixed__depth__iterator.html">fixed_depth_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#4dad5d0de897c6ff3062151e17ecd192">end_fixed</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;, unsigned int) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return fixed-depth iterator to end of the nodes at given depth. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7def49a7fab1b74d30bdf73fe27c3cfd"></a><!-- doxytag: member="tree::begin" ref="7def49a7fab1b74d30bdf73fe27c3cfd" args="(const iterator_base &amp;) const " -->
<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#7def49a7fab1b74d30bdf73fe27c3cfd">begin</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return sibling iterator to the first child of given node. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ee5bbcc93836876ebb7a4f85f9d562f3"></a><!-- doxytag: member="tree::end" ref="ee5bbcc93836876ebb7a4f85f9d562f3" args="(const iterator_base &amp;) const " -->
<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#ee5bbcc93836876ebb7a4f85f9d562f3">end</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return sibling iterator to the end of the children of a given node. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="aaaa1622d2d58ecda846640bd8f8bd28"></a><!-- doxytag: member="tree::parent" ref="aaaa1622d2d58ecda846640bd8f8bd28" args="(iter) const " -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#aaaa1622d2d58ecda846640bd8f8bd28">parent</a> (iter) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return iterator to the parent of a node. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="6d38ef0b2b73266cbc39ab021482bb50"></a><!-- doxytag: member="tree::previous_sibling" ref="6d38ef0b2b73266cbc39ab021482bb50" args="(iter) const " -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#6d38ef0b2b73266cbc39ab021482bb50">previous_sibling</a> (iter) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return iterator to the previous sibling of a node. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="4e3ea50e0949bd05e27ecb9c6b7162ff"></a><!-- doxytag: member="tree::next_sibling" ref="4e3ea50e0949bd05e27ecb9c6b7162ff" args="(iter) const " -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#4e3ea50e0949bd05e27ecb9c6b7162ff">next_sibling</a> (iter) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return iterator to the next sibling of a node. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ce3b299e157ec177230a0144771b2a7e"></a><!-- doxytag: member="tree::next_at_same_depth" ref="ce3b299e157ec177230a0144771b2a7e" args="(iter) const " -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#ce3b299e157ec177230a0144771b2a7e">next_at_same_depth</a> (iter) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return iterator to the next node at a given depth. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a8cf6dfe17504abfc0ffabb5a4ba9d0a"></a><!-- doxytag: member="tree::clear" ref="a8cf6dfe17504abfc0ffabb5a4ba9d0a" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a8cf6dfe17504abfc0ffabb5a4ba9d0a">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase all nodes of the <a class="el" href="classtree.html">tree</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="3eb424c89446ae17a747d2aca2cdda4b"></a><!-- doxytag: member="tree::erase" ref="3eb424c89446ae17a747d2aca2cdda4b" args="(iter)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#3eb424c89446ae17a747d2aca2cdda4b">erase</a> (iter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase element at position pointed to by iterator, return incremented iterator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="05d5fd71c206efc8ac30df5cd46176bc"></a><!-- doxytag: member="tree::erase_children" ref="05d5fd71c206efc8ac30df5cd46176bc" args="(const iterator_base &amp;)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#05d5fd71c206efc8ac30df5cd46176bc">erase_children</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase all children of the node pointed to by iterator. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="8d68e95f5088d48cb54fd6ae381729f0"></a><!-- doxytag: member="tree::append_child" ref="8d68e95f5088d48cb54fd6ae381729f0" args="(iter position)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#8d68e95f5088d48cb54fd6ae381729f0">append_child</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert empty node as last child of node pointed to by position. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="9318fa77c4e10ec0a9a26a0d08f182a2"></a><!-- doxytag: member="tree::append_child" ref="9318fa77c4e10ec0a9a26a0d08f182a2" args="(iter position, const T &amp;x)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#9318fa77c4e10ec0a9a26a0d08f182a2">append_child</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, const T &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert node as last child of node pointed to by position. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="1fb4734b783fed4a66c24130af67316e"></a><!-- doxytag: member="tree::append_child" ref="1fb4734b783fed4a66c24130af67316e" args="(iter position, iter other_position)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#1fb4734b783fed4a66c24130af67316e">append_child</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, iter other_position)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append the node (plus its children) at other_position as a child of position. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="92ab22e0a98d8899c0d1b6c9d0a85465"></a><!-- doxytag: member="tree::append_children" ref="92ab22e0a98d8899c0d1b6c9d0a85465" args="(iter position, sibling_iterator from, sibling_iterator to)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#92ab22e0a98d8899c0d1b6c9d0a85465">append_children</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> from, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> to)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append the nodes in the from-to range (plus their children) as children of position. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="16e33d0c3cd419a9fc8fd14e8d1a0768"></a><!-- doxytag: member="tree::set_head" ref="16e33d0c3cd419a9fc8fd14e8d1a0768" args="(const T &amp;x)" -->
<a class="el" href="classtree_1_1pre__order__iterator.html">pre_order_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#16e33d0c3cd419a9fc8fd14e8d1a0768">set_head</a> (const T &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Short-hand to insert topmost node in otherwise empty <a class="el" href="classtree.html">tree</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="c3d19d3a42f91618267674f2c236aad9"></a><!-- doxytag: member="tree::insert" ref="c3d19d3a42f91618267674f2c236aad9" args="(iter position, const T &amp;x)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#c3d19d3a42f91618267674f2c236aad9">insert</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, const T &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert node as previous sibling of node pointed to by position. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="228da1f727711e92bc8dd64b10f7dfff"></a><!-- doxytag: member="tree::insert" ref="228da1f727711e92bc8dd64b10f7dfff" args="(sibling_iterator position, const T &amp;x)" -->
<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#228da1f727711e92bc8dd64b10f7dfff">insert</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, const T &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialisation of previous member. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="d66d55d58b48ce0a8d7a5b41abe923d5"></a><!-- doxytag: member="tree::insert_subtree" ref="d66d55d58b48ce0a8d7a5b41abe923d5" args="(iter position, const iterator_base &amp;subtree)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#d66d55d58b48ce0a8d7a5b41abe923d5">insert_subtree</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;subtree)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert node (with children) pointed to by subtree as previous sibling of node pointed to by position. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="215ab56bd13f59c661eb2298e373ff3e"></a><!-- doxytag: member="tree::insert_after" ref="215ab56bd13f59c661eb2298e373ff3e" args="(iter position, const T &amp;x)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#215ab56bd13f59c661eb2298e373ff3e">insert_after</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, const T &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert node as next sibling of node pointed to by position. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="4885e968c82655ebebea5d0927b7e9f4"></a><!-- doxytag: member="tree::replace" ref="4885e968c82655ebebea5d0927b7e9f4" args="(iter position, const T &amp;x)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#4885e968c82655ebebea5d0927b7e9f4">replace</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, const T &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace node at 'position' with other node (keeping same children); 'position' becomes invalid. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="5d2ad4532598f26c84b1ab0ec84a5d62"></a><!-- doxytag: member="tree::replace" ref="5d2ad4532598f26c84b1ab0ec84a5d62" args="(iter position, const iterator_base &amp;from)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#5d2ad4532598f26c84b1ab0ec84a5d62">replace</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;from)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace node at 'position' with subtree starting at 'from' (do not erase subtree at 'from'); see above. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="246ce66bdbc54066ff9b3f47df9adde3"></a><!-- doxytag: member="tree::replace" ref="246ce66bdbc54066ff9b3f47df9adde3" args="(sibling_iterator orig_begin, sibling_iterator orig_end, sibling_iterator new_begin, sibling_iterator new_end)" -->
<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#246ce66bdbc54066ff9b3f47df9adde3">replace</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> orig_begin, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> orig_end, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> new_begin, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> new_end)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace string of siblings (plus their children) with copy of a new string (with children); see above. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="479c8e3f748608a9b9fb91e58e18998c"></a><!-- doxytag: member="tree::flatten" ref="479c8e3f748608a9b9fb91e58e18998c" args="(iter position)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#479c8e3f748608a9b9fb91e58e18998c">flatten</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move all children of node at 'position' to be siblings, returns position. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="32b88523e2d5b6c78381b7da9455be5e"></a><!-- doxytag: member="tree::reparent" ref="32b88523e2d5b6c78381b7da9455be5e" args="(iter position, sibling_iterator begin, sibling_iterator end)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#32b88523e2d5b6c78381b7da9455be5e">reparent</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> begin, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> end)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move nodes in range to be children of 'position'. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="021a394ff7139df8573e2cb80e6beaa2"></a><!-- doxytag: member="tree::reparent" ref="021a394ff7139df8573e2cb80e6beaa2" args="(iter position, iter from)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#021a394ff7139df8573e2cb80e6beaa2">reparent</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, iter from)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move all child nodes of 'from' to be children of 'position'. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="e7f72ba46cd061f71720c731b4a9bf63"></a><!-- doxytag: member="tree::move_after" ref="e7f72ba46cd061f71720c731b4a9bf63" args="(iter target, iter source)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#e7f72ba46cd061f71720c731b4a9bf63">move_after</a> (iter target, iter source)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move 'source' node (plus its children) to become the next sibling of 'target'. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="b45aa15042445a81b13873d3ef4a2e86"></a><!-- doxytag: member="tree::move_before" ref="b45aa15042445a81b13873d3ef4a2e86" args="(iter target, iter source)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#b45aa15042445a81b13873d3ef4a2e86">move_before</a> (iter target, iter source)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move 'source' node (plus its children) to become the previous sibling of 'target'. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a4f8b906b2758eec530e28387b819284"></a><!-- doxytag: member="tree::move_ontop" ref="a4f8b906b2758eec530e28387b819284" args="(iter target, iter source)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#a4f8b906b2758eec530e28387b819284">move_ontop</a> (iter target, iter source)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move 'source' node (plus its children) to become the node at 'target' (erasing the node at 'target'). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1e3cd901f8f8d8a3da0e1d32e9282db1"></a><!-- doxytag: member="tree::merge" ref="1e3cd901f8f8d8a3da0e1d32e9282db1" args="(sibling_iterator, sibling_iterator, sibling_iterator, sibling_iterator, bool duplicate_leaves=false)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#1e3cd901f8f8d8a3da0e1d32e9282db1">merge</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>, bool duplicate_leaves=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Merge with other <a class="el" href="classtree.html">tree</a>, creating new branches and leaves only if they are not already present. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="498ec42a5eb44cba8bf9ef6e7fd5db9e"></a><!-- doxytag: member="tree::sort" ref="498ec42a5eb44cba8bf9ef6e7fd5db9e" args="(sibling_iterator from, sibling_iterator to, bool deep=false)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#498ec42a5eb44cba8bf9ef6e7fd5db9e">sort</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> from, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> to, bool deep=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sort (std::sort only moves values of nodes, this one moves children as well). <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="f187f42c28a39304649ee41d3464f2ef"></a><!-- doxytag: member="tree::sort" ref="f187f42c28a39304649ee41d3464f2ef" args="(sibling_iterator from, sibling_iterator to, StrictWeakOrdering comp, bool deep=false)" -->
template&lt;class StrictWeakOrdering&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>sort</b> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> from, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> to, StrictWeakOrdering comp, bool deep=false)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="59488f63fc6ad997809d971c48ecfc04"></a><!-- doxytag: member="tree::equal" ref="59488f63fc6ad997809d971c48ecfc04" args="(const iter &amp;one, const iter &amp;two, const iter &amp;three) const " -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#59488f63fc6ad997809d971c48ecfc04">equal</a> (const iter &amp;one, const iter &amp;two, const iter &amp;three) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two ranges of nodes (compares nodes as well as <a class="el" href="classtree.html">tree</a> structure). <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="7ce7ff12a68be494b28925b2f7184a29"></a><!-- doxytag: member="tree::equal" ref="7ce7ff12a68be494b28925b2f7184a29" args="(const iter &amp;one, const iter &amp;two, const iter &amp;three, BinaryPredicate) const " -->
template&lt;typename iter, class BinaryPredicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>equal</b> (const iter &amp;one, const iter &amp;two, const iter &amp;three, BinaryPredicate) const </td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="6e2e76dfa6f0f51ca6f573d73b0c1b28"></a><!-- doxytag: member="tree::equal_subtree" ref="6e2e76dfa6f0f51ca6f573d73b0c1b28" args="(const iter &amp;one, const iter &amp;two) const " -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>equal_subtree</b> (const iter &amp;one, const iter &amp;two) const </td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="5e8445150c43058416d16b4846ff0f15"></a><!-- doxytag: member="tree::equal_subtree" ref="5e8445150c43058416d16b4846ff0f15" args="(const iter &amp;one, const iter &amp;two, BinaryPredicate) const " -->
template&lt;typename iter, class BinaryPredicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>equal_subtree</b> (const iter &amp;one, const iter &amp;two, BinaryPredicate) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5948cb430e05082d3c7ee9e89b726af5"></a><!-- doxytag: member="tree::subtree" ref="5948cb430e05082d3c7ee9e89b726af5" args="(sibling_iterator from, sibling_iterator to) const " -->
<a class="el" href="classtree.html">tree</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#5948cb430e05082d3c7ee9e89b726af5">subtree</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> from, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> to) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract a new <a class="el" href="classtree.html">tree</a> formed by the range of siblings plus all their children. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="830cccac50df183c44c6ff83cab5a27f"></a><!-- doxytag: member="tree::subtree" ref="830cccac50df183c44c6ff83cab5a27f" args="(tree &amp;, sibling_iterator from, sibling_iterator to) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>subtree</b> (<a class="el" href="classtree.html">tree</a> &amp;, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> from, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> to) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e842f9b70235bc2412b3c43bca759448"></a><!-- doxytag: member="tree::swap" ref="e842f9b70235bc2412b3c43bca759448" args="(sibling_iterator it)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#e842f9b70235bc2412b3c43bca759448">swap</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> it)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exchange the node (plus subtree) with its sibling node (do nothing if no sibling present). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="219ff1bfc99f78fd9a2db71f41891523"></a><!-- doxytag: member="tree::size" ref="219ff1bfc99f78fd9a2db71f41891523" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#219ff1bfc99f78fd9a2db71f41891523">size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Count the total number of nodes. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e9f7fd30c51443d46ca8941d5bc06da2"></a><!-- doxytag: member="tree::empty" ref="e9f7fd30c51443d46ca8941d5bc06da2" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#e9f7fd30c51443d46ca8941d5bc06da2">empty</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if <a class="el" href="classtree.html">tree</a> is empty. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="16c66be75ca89c999a9c4a68497b05a1"></a><!-- doxytag: member="tree::depth" ref="16c66be75ca89c999a9c4a68497b05a1" args="(const iterator_base &amp;) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#16c66be75ca89c999a9c4a68497b05a1">depth</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the depth to the root. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="96f82a90a3e21e82f486f325b0cf9faa"></a><!-- doxytag: member="tree::number_of_children" ref="96f82a90a3e21e82f486f325b0cf9faa" args="(const iterator_base &amp;) const " -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#96f82a90a3e21e82f486f325b0cf9faa">number_of_children</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Count the number of children of node at position. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3cddce970c4d44af57cf9ec0d7c3d009"></a><!-- doxytag: member="tree::number_of_siblings" ref="3cddce970c4d44af57cf9ec0d7c3d009" args="(const iterator_base &amp;) const " -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#3cddce970c4d44af57cf9ec0d7c3d009">number_of_siblings</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Count the number of 'next' siblings of node at iterator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="825e2106781e846bdd8732c117dc21db"></a><!-- doxytag: member="tree::is_in_subtree" ref="825e2106781e846bdd8732c117dc21db" args="(const iterator_base &amp;position, const iterator_base &amp;begin, const iterator_base &amp;end) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#825e2106781e846bdd8732c117dc21db">is_in_subtree</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;<a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;begin, const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;end) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine whether node at position is in the subtrees with root in the range. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9605b028195248894dc8cf506cd256e3"></a><!-- doxytag: member="tree::is_valid" ref="9605b028195248894dc8cf506cd256e3" args="(const iterator_base &amp;) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#9605b028195248894dc8cf506cd256e3">is_valid</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine whether the iterator is an 'end' iterator and thus not actually pointing to a node. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="de5ec1ba55f94165062e50d01ec35d86"></a><!-- doxytag: member="tree::index" ref="de5ec1ba55f94165062e50d01ec35d86" args="(sibling_iterator it) const " -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#de5ec1ba55f94165062e50d01ec35d86">index</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> it) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the index of a node in the range of siblings to which it belongs. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a614f997d8c45de7a5ea25733ac036be"></a><!-- doxytag: member="tree::child" ref="a614f997d8c45de7a5ea25733ac036be" args="(const iterator_base &amp;position, unsigned int) const " -->
<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a614f997d8c45de7a5ea25733ac036be">child</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;<a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, unsigned int) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inverse of 'index': return the n-th child of the node at position. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5925c012af64fe91a3a5ed39e3ba9d9a"></a><!-- doxytag: member="tree::tree" ref="5925c012af64fe91a3a5ed39e3ba9d9a" args="(const T &amp;)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>tree</b> (const T &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b72378e7a772a82f90d91ef7493f27bc"></a><!-- doxytag: member="tree::tree" ref="b72378e7a772a82f90d91ef7493f27bc" args="(const iterator_base &amp;)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>tree</b> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e9e06b40929dfd33a1024bd422beedb6"></a><!-- doxytag: member="tree::tree" ref="e9e06b40929dfd33a1024bd422beedb6" args="(const tree&lt; T, tree_node_allocator &gt; &amp;)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>tree</b> (const <a class="el" href="classtree.html">tree</a>&lt; T, tree_node_allocator &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9561c0c73b0605f32bf82a026eaf216a"></a><!-- doxytag: member="tree::operator=" ref="9561c0c73b0605f32bf82a026eaf216a" args="(const tree&lt; T, tree_node_allocator &gt; &amp;)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classtree.html">tree</a>&lt; T, tree_node_allocator &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bb0b39dab780d42d75dfa71a1609462b"></a><!-- doxytag: member="tree::begin" ref="bb0b39dab780d42d75dfa71a1609462b" args="() const " -->
<a class="el" href="classtree_1_1pre__order__iterator.html">pre_order_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#bb0b39dab780d42d75dfa71a1609462b">begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return iterator to the beginning of the <a class="el" href="classtree.html">tree</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c51a8218d988dc75fe0a1a986cbfdd72"></a><!-- doxytag: member="tree::end" ref="c51a8218d988dc75fe0a1a986cbfdd72" args="() const " -->
<a class="el" href="classtree_1_1pre__order__iterator.html">pre_order_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#c51a8218d988dc75fe0a1a986cbfdd72">end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return iterator to the end of the <a class="el" href="classtree.html">tree</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c589b0b9d7b7bec68232c37de5a7318f"></a><!-- doxytag: member="tree::begin_post" ref="c589b0b9d7b7bec68232c37de5a7318f" args="() const " -->
<a class="el" href="classtree_1_1post__order__iterator.html">post_order_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#c589b0b9d7b7bec68232c37de5a7318f">begin_post</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return post-order iterator to the beginning of the <a class="el" href="classtree.html">tree</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="874c4d85ee7631a996874d32429ec575"></a><!-- doxytag: member="tree::end_post" ref="874c4d85ee7631a996874d32429ec575" args="() const " -->
<a class="el" href="classtree_1_1post__order__iterator.html">post_order_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#874c4d85ee7631a996874d32429ec575">end_post</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return post-order iterator to the end of the <a class="el" href="classtree.html">tree</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="32efdda22e59c2e627fc8de2ea4b2729"></a><!-- doxytag: member="tree::begin_fixed" ref="32efdda22e59c2e627fc8de2ea4b2729" args="(const iterator_base &amp;, unsigned int) const " -->
<a class="el" href="classtree_1_1fixed__depth__iterator.html">fixed_depth_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#32efdda22e59c2e627fc8de2ea4b2729">begin_fixed</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;, unsigned int) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return fixed-depth iterator to the first node at a given depth. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4dad5d0de897c6ff3062151e17ecd192"></a><!-- doxytag: member="tree::end_fixed" ref="4dad5d0de897c6ff3062151e17ecd192" args="(const iterator_base &amp;, unsigned int) const " -->
<a class="el" href="classtree_1_1fixed__depth__iterator.html">fixed_depth_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#4dad5d0de897c6ff3062151e17ecd192">end_fixed</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;, unsigned int) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return fixed-depth iterator to end of the nodes at given depth. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7def49a7fab1b74d30bdf73fe27c3cfd"></a><!-- doxytag: member="tree::begin" ref="7def49a7fab1b74d30bdf73fe27c3cfd" args="(const iterator_base &amp;) const " -->
<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#7def49a7fab1b74d30bdf73fe27c3cfd">begin</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return sibling iterator to the first child of given node. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ee5bbcc93836876ebb7a4f85f9d562f3"></a><!-- doxytag: member="tree::end" ref="ee5bbcc93836876ebb7a4f85f9d562f3" args="(const iterator_base &amp;) const " -->
<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#ee5bbcc93836876ebb7a4f85f9d562f3">end</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return sibling iterator to the end of the children of a given node. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="aaaa1622d2d58ecda846640bd8f8bd28"></a><!-- doxytag: member="tree::parent" ref="aaaa1622d2d58ecda846640bd8f8bd28" args="(iter) const " -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#aaaa1622d2d58ecda846640bd8f8bd28">parent</a> (iter) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return iterator to the parent of a node. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="6d38ef0b2b73266cbc39ab021482bb50"></a><!-- doxytag: member="tree::previous_sibling" ref="6d38ef0b2b73266cbc39ab021482bb50" args="(iter) const " -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#6d38ef0b2b73266cbc39ab021482bb50">previous_sibling</a> (iter) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return iterator to the previous sibling of a node. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="4e3ea50e0949bd05e27ecb9c6b7162ff"></a><!-- doxytag: member="tree::next_sibling" ref="4e3ea50e0949bd05e27ecb9c6b7162ff" args="(iter) const " -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#4e3ea50e0949bd05e27ecb9c6b7162ff">next_sibling</a> (iter) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return iterator to the next sibling of a node. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ce3b299e157ec177230a0144771b2a7e"></a><!-- doxytag: member="tree::next_at_same_depth" ref="ce3b299e157ec177230a0144771b2a7e" args="(iter) const " -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#ce3b299e157ec177230a0144771b2a7e">next_at_same_depth</a> (iter) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return iterator to the next node at a given depth. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a8cf6dfe17504abfc0ffabb5a4ba9d0a"></a><!-- doxytag: member="tree::clear" ref="a8cf6dfe17504abfc0ffabb5a4ba9d0a" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a8cf6dfe17504abfc0ffabb5a4ba9d0a">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase all nodes of the <a class="el" href="classtree.html">tree</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="3eb424c89446ae17a747d2aca2cdda4b"></a><!-- doxytag: member="tree::erase" ref="3eb424c89446ae17a747d2aca2cdda4b" args="(iter)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#3eb424c89446ae17a747d2aca2cdda4b">erase</a> (iter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase element at position pointed to by iterator, return incremented iterator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="05d5fd71c206efc8ac30df5cd46176bc"></a><!-- doxytag: member="tree::erase_children" ref="05d5fd71c206efc8ac30df5cd46176bc" args="(const iterator_base &amp;)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#05d5fd71c206efc8ac30df5cd46176bc">erase_children</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase all children of the node pointed to by iterator. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="8d68e95f5088d48cb54fd6ae381729f0"></a><!-- doxytag: member="tree::append_child" ref="8d68e95f5088d48cb54fd6ae381729f0" args="(iter position)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#8d68e95f5088d48cb54fd6ae381729f0">append_child</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert empty node as last child of node pointed to by position. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="9318fa77c4e10ec0a9a26a0d08f182a2"></a><!-- doxytag: member="tree::append_child" ref="9318fa77c4e10ec0a9a26a0d08f182a2" args="(iter position, const T &amp;x)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#9318fa77c4e10ec0a9a26a0d08f182a2">append_child</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, const T &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert node as last child of node pointed to by position. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="1fb4734b783fed4a66c24130af67316e"></a><!-- doxytag: member="tree::append_child" ref="1fb4734b783fed4a66c24130af67316e" args="(iter position, iter other_position)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#1fb4734b783fed4a66c24130af67316e">append_child</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, iter other_position)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append the node (plus its children) at other_position as a child of position. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="92ab22e0a98d8899c0d1b6c9d0a85465"></a><!-- doxytag: member="tree::append_children" ref="92ab22e0a98d8899c0d1b6c9d0a85465" args="(iter position, sibling_iterator from, sibling_iterator to)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#92ab22e0a98d8899c0d1b6c9d0a85465">append_children</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> from, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> to)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append the nodes in the from-to range (plus their children) as children of position. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="16e33d0c3cd419a9fc8fd14e8d1a0768"></a><!-- doxytag: member="tree::set_head" ref="16e33d0c3cd419a9fc8fd14e8d1a0768" args="(const T &amp;x)" -->
<a class="el" href="classtree_1_1pre__order__iterator.html">pre_order_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#16e33d0c3cd419a9fc8fd14e8d1a0768">set_head</a> (const T &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Short-hand to insert topmost node in otherwise empty <a class="el" href="classtree.html">tree</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="c3d19d3a42f91618267674f2c236aad9"></a><!-- doxytag: member="tree::insert" ref="c3d19d3a42f91618267674f2c236aad9" args="(iter position, const T &amp;x)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#c3d19d3a42f91618267674f2c236aad9">insert</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, const T &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert node as previous sibling of node pointed to by position. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="228da1f727711e92bc8dd64b10f7dfff"></a><!-- doxytag: member="tree::insert" ref="228da1f727711e92bc8dd64b10f7dfff" args="(sibling_iterator position, const T &amp;x)" -->
<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#228da1f727711e92bc8dd64b10f7dfff">insert</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, const T &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialisation of previous member. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="d66d55d58b48ce0a8d7a5b41abe923d5"></a><!-- doxytag: member="tree::insert_subtree" ref="d66d55d58b48ce0a8d7a5b41abe923d5" args="(iter position, const iterator_base &amp;subtree)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#d66d55d58b48ce0a8d7a5b41abe923d5">insert_subtree</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;subtree)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert node (with children) pointed to by subtree as previous sibling of node pointed to by position. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="215ab56bd13f59c661eb2298e373ff3e"></a><!-- doxytag: member="tree::insert_after" ref="215ab56bd13f59c661eb2298e373ff3e" args="(iter position, const T &amp;x)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#215ab56bd13f59c661eb2298e373ff3e">insert_after</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, const T &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert node as next sibling of node pointed to by position. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="4885e968c82655ebebea5d0927b7e9f4"></a><!-- doxytag: member="tree::replace" ref="4885e968c82655ebebea5d0927b7e9f4" args="(iter position, const T &amp;x)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#4885e968c82655ebebea5d0927b7e9f4">replace</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, const T &amp;x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace node at 'position' with other node (keeping same children); 'position' becomes invalid. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="5d2ad4532598f26c84b1ab0ec84a5d62"></a><!-- doxytag: member="tree::replace" ref="5d2ad4532598f26c84b1ab0ec84a5d62" args="(iter position, const iterator_base &amp;from)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#5d2ad4532598f26c84b1ab0ec84a5d62">replace</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;from)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace node at 'position' with subtree starting at 'from' (do not erase subtree at 'from'); see above. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="246ce66bdbc54066ff9b3f47df9adde3"></a><!-- doxytag: member="tree::replace" ref="246ce66bdbc54066ff9b3f47df9adde3" args="(sibling_iterator orig_begin, sibling_iterator orig_end, sibling_iterator new_begin, sibling_iterator new_end)" -->
<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#246ce66bdbc54066ff9b3f47df9adde3">replace</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> orig_begin, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> orig_end, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> new_begin, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> new_end)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace string of siblings (plus their children) with copy of a new string (with children); see above. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="479c8e3f748608a9b9fb91e58e18998c"></a><!-- doxytag: member="tree::flatten" ref="479c8e3f748608a9b9fb91e58e18998c" args="(iter position)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#479c8e3f748608a9b9fb91e58e18998c">flatten</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move all children of node at 'position' to be siblings, returns position. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="32b88523e2d5b6c78381b7da9455be5e"></a><!-- doxytag: member="tree::reparent" ref="32b88523e2d5b6c78381b7da9455be5e" args="(iter position, sibling_iterator begin, sibling_iterator end)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#32b88523e2d5b6c78381b7da9455be5e">reparent</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> begin, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> end)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move nodes in range to be children of 'position'. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="021a394ff7139df8573e2cb80e6beaa2"></a><!-- doxytag: member="tree::reparent" ref="021a394ff7139df8573e2cb80e6beaa2" args="(iter position, iter from)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#021a394ff7139df8573e2cb80e6beaa2">reparent</a> (iter <a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, iter from)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move all child nodes of 'from' to be children of 'position'. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="e7f72ba46cd061f71720c731b4a9bf63"></a><!-- doxytag: member="tree::move_after" ref="e7f72ba46cd061f71720c731b4a9bf63" args="(iter target, iter source)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#e7f72ba46cd061f71720c731b4a9bf63">move_after</a> (iter target, iter source)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move 'source' node (plus its children) to become the next sibling of 'target'. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="b45aa15042445a81b13873d3ef4a2e86"></a><!-- doxytag: member="tree::move_before" ref="b45aa15042445a81b13873d3ef4a2e86" args="(iter target, iter source)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#b45aa15042445a81b13873d3ef4a2e86">move_before</a> (iter target, iter source)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move 'source' node (plus its children) to become the previous sibling of 'target'. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a4f8b906b2758eec530e28387b819284"></a><!-- doxytag: member="tree::move_ontop" ref="a4f8b906b2758eec530e28387b819284" args="(iter target, iter source)" -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">iter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#a4f8b906b2758eec530e28387b819284">move_ontop</a> (iter target, iter source)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move 'source' node (plus its children) to become the node at 'target' (erasing the node at 'target'). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1e3cd901f8f8d8a3da0e1d32e9282db1"></a><!-- doxytag: member="tree::merge" ref="1e3cd901f8f8d8a3da0e1d32e9282db1" args="(sibling_iterator, sibling_iterator, sibling_iterator, sibling_iterator, bool duplicate_leaves=false)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#1e3cd901f8f8d8a3da0e1d32e9282db1">merge</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>, bool duplicate_leaves=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Merge with other <a class="el" href="classtree.html">tree</a>, creating new branches and leaves only if they are not already present. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="498ec42a5eb44cba8bf9ef6e7fd5db9e"></a><!-- doxytag: member="tree::sort" ref="498ec42a5eb44cba8bf9ef6e7fd5db9e" args="(sibling_iterator from, sibling_iterator to, bool deep=false)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#498ec42a5eb44cba8bf9ef6e7fd5db9e">sort</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> from, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> to, bool deep=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sort (std::sort only moves values of nodes, this one moves children as well). <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="f187f42c28a39304649ee41d3464f2ef"></a><!-- doxytag: member="tree::sort" ref="f187f42c28a39304649ee41d3464f2ef" args="(sibling_iterator from, sibling_iterator to, StrictWeakOrdering comp, bool deep=false)" -->
template&lt;class StrictWeakOrdering&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>sort</b> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> from, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> to, StrictWeakOrdering comp, bool deep=false)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="59488f63fc6ad997809d971c48ecfc04"></a><!-- doxytag: member="tree::equal" ref="59488f63fc6ad997809d971c48ecfc04" args="(const iter &amp;one, const iter &amp;two, const iter &amp;three) const " -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtree.html#59488f63fc6ad997809d971c48ecfc04">equal</a> (const iter &amp;one, const iter &amp;two, const iter &amp;three) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare two ranges of nodes (compares nodes as well as <a class="el" href="classtree.html">tree</a> structure). <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="7ce7ff12a68be494b28925b2f7184a29"></a><!-- doxytag: member="tree::equal" ref="7ce7ff12a68be494b28925b2f7184a29" args="(const iter &amp;one, const iter &amp;two, const iter &amp;three, BinaryPredicate) const " -->
template&lt;typename iter, class BinaryPredicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>equal</b> (const iter &amp;one, const iter &amp;two, const iter &amp;three, BinaryPredicate) const </td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="6e2e76dfa6f0f51ca6f573d73b0c1b28"></a><!-- doxytag: member="tree::equal_subtree" ref="6e2e76dfa6f0f51ca6f573d73b0c1b28" args="(const iter &amp;one, const iter &amp;two) const " -->
template&lt;typename iter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>equal_subtree</b> (const iter &amp;one, const iter &amp;two) const </td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="5e8445150c43058416d16b4846ff0f15"></a><!-- doxytag: member="tree::equal_subtree" ref="5e8445150c43058416d16b4846ff0f15" args="(const iter &amp;one, const iter &amp;two, BinaryPredicate) const " -->
template&lt;typename iter, class BinaryPredicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>equal_subtree</b> (const iter &amp;one, const iter &amp;two, BinaryPredicate) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5948cb430e05082d3c7ee9e89b726af5"></a><!-- doxytag: member="tree::subtree" ref="5948cb430e05082d3c7ee9e89b726af5" args="(sibling_iterator from, sibling_iterator to) const " -->
<a class="el" href="classtree.html">tree</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#5948cb430e05082d3c7ee9e89b726af5">subtree</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> from, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> to) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract a new <a class="el" href="classtree.html">tree</a> formed by the range of siblings plus all their children. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="830cccac50df183c44c6ff83cab5a27f"></a><!-- doxytag: member="tree::subtree" ref="830cccac50df183c44c6ff83cab5a27f" args="(tree &amp;, sibling_iterator from, sibling_iterator to) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>subtree</b> (<a class="el" href="classtree.html">tree</a> &amp;, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> from, <a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> to) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e842f9b70235bc2412b3c43bca759448"></a><!-- doxytag: member="tree::swap" ref="e842f9b70235bc2412b3c43bca759448" args="(sibling_iterator it)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#e842f9b70235bc2412b3c43bca759448">swap</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> it)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exchange the node (plus subtree) with its sibling node (do nothing if no sibling present). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="219ff1bfc99f78fd9a2db71f41891523"></a><!-- doxytag: member="tree::size" ref="219ff1bfc99f78fd9a2db71f41891523" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#219ff1bfc99f78fd9a2db71f41891523">size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Count the total number of nodes. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e9f7fd30c51443d46ca8941d5bc06da2"></a><!-- doxytag: member="tree::empty" ref="e9f7fd30c51443d46ca8941d5bc06da2" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#e9f7fd30c51443d46ca8941d5bc06da2">empty</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if <a class="el" href="classtree.html">tree</a> is empty. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="16c66be75ca89c999a9c4a68497b05a1"></a><!-- doxytag: member="tree::depth" ref="16c66be75ca89c999a9c4a68497b05a1" args="(const iterator_base &amp;) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#16c66be75ca89c999a9c4a68497b05a1">depth</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the depth to the root. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="96f82a90a3e21e82f486f325b0cf9faa"></a><!-- doxytag: member="tree::number_of_children" ref="96f82a90a3e21e82f486f325b0cf9faa" args="(const iterator_base &amp;) const " -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#96f82a90a3e21e82f486f325b0cf9faa">number_of_children</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Count the number of children of node at position. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3cddce970c4d44af57cf9ec0d7c3d009"></a><!-- doxytag: member="tree::number_of_siblings" ref="3cddce970c4d44af57cf9ec0d7c3d009" args="(const iterator_base &amp;) const " -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#3cddce970c4d44af57cf9ec0d7c3d009">number_of_siblings</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Count the number of 'next' siblings of node at iterator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="825e2106781e846bdd8732c117dc21db"></a><!-- doxytag: member="tree::is_in_subtree" ref="825e2106781e846bdd8732c117dc21db" args="(const iterator_base &amp;position, const iterator_base &amp;begin, const iterator_base &amp;end) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#825e2106781e846bdd8732c117dc21db">is_in_subtree</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;<a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;begin, const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;end) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine whether node at position is in the subtrees with root in the range. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9605b028195248894dc8cf506cd256e3"></a><!-- doxytag: member="tree::is_valid" ref="9605b028195248894dc8cf506cd256e3" args="(const iterator_base &amp;) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#9605b028195248894dc8cf506cd256e3">is_valid</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine whether the iterator is an 'end' iterator and thus not actually pointing to a node. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="de5ec1ba55f94165062e50d01ec35d86"></a><!-- doxytag: member="tree::index" ref="de5ec1ba55f94165062e50d01ec35d86" args="(sibling_iterator it) const " -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#de5ec1ba55f94165062e50d01ec35d86">index</a> (<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a> it) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the index of a node in the range of siblings to which it belongs. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a614f997d8c45de7a5ea25733ac036be"></a><!-- doxytag: member="tree::child" ref="a614f997d8c45de7a5ea25733ac036be" args="(const iterator_base &amp;position, unsigned int) const " -->
<a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#a614f997d8c45de7a5ea25733ac036be">child</a> (const <a class="el" href="classtree_1_1iterator__base.html">iterator_base</a> &amp;<a class="el" href="fx-0_89_80_2lib_2ofx__sgml_8cpp.html#4da8008b6f110050513003edf67a2495">position</a>, unsigned int) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inverse of 'index': return the n-th child of the node at position. <br></td></tr>
<tr><td colspan="2"><br><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="10991cbf1497e125c0ef04d6e292e32b"></a><!-- doxytag: member="tree::head" ref="10991cbf1497e125c0ef04d6e292e32b" args="" -->
<a class="el" href="classtree__node__.html">tree_node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#10991cbf1497e125c0ef04d6e292e32b">head</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e1dbb80115ba483e37d081a2256c239b"></a><!-- doxytag: member="tree::feet" ref="e1dbb80115ba483e37d081a2256c239b" args="" -->
<a class="el" href="classtree__node__.html">tree_node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#e1dbb80115ba483e37d081a2256c239b">feet</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="10991cbf1497e125c0ef04d6e292e32b"></a><!-- doxytag: member="tree::head" ref="10991cbf1497e125c0ef04d6e292e32b" args="" -->
<a class="el" href="classtree__node__.html">tree_node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#10991cbf1497e125c0ef04d6e292e32b">head</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="10991cbf1497e125c0ef04d6e292e32b"></a><!-- doxytag: member="tree::head" ref="10991cbf1497e125c0ef04d6e292e32b" args="" -->
<a class="el" href="classtree__node__.html">tree_node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#10991cbf1497e125c0ef04d6e292e32b">head</a></td></tr>

<tr><td colspan="2"><br><h2>Protected Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="672d078d87ae97c58b732a940d7b8ca8"></a><!-- doxytag: member="tree::tree_node" ref="672d078d87ae97c58b732a940d7b8ca8" args="" -->
typedef <a class="el" href="classtree__node__.html">tree_node_</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#672d078d87ae97c58b732a940d7b8ca8">tree_node</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="672d078d87ae97c58b732a940d7b8ca8"></a><!-- doxytag: member="tree::tree_node" ref="672d078d87ae97c58b732a940d7b8ca8" args="" -->
typedef <a class="el" href="classtree__node__.html">tree_node_</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#672d078d87ae97c58b732a940d7b8ca8">tree_node</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="672d078d87ae97c58b732a940d7b8ca8"></a><!-- doxytag: member="tree::tree_node" ref="672d078d87ae97c58b732a940d7b8ca8" args="" -->
typedef <a class="el" href="classtree__node__.html">tree_node_</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree.html#672d078d87ae97c58b732a940d7b8ca8">tree_node</a></td></tr>

<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>compare_nodes</b></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparator class for two nodes of a <a class="el" href="classtree.html">tree</a> (used for sorting and searching). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree_1_1fixed__depth__iterator.html">fixed_depth_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator which traverses only the nodes at a given depth from the root.  <a href="classtree_1_1fixed__depth__iterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree_1_1iterator__base.html">iterator_base</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for iterators, only pointers stored, no traversal logic.  <a href="classtree_1_1iterator__base.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree_1_1iterator__base__less.html">iterator_base_less</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparator class for iterators (compares the actual node content, not pointer values).  <a href="classtree_1_1iterator__base__less.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree_1_1post__order__iterator.html">post_order_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Depth-first iterator, first accessing the children, then the node itself.  <a href="classtree_1_1post__order__iterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree_1_1pre__order__iterator.html">pre_order_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Depth-first iterator, first accessing the node, then its children.  <a href="classtree_1_1pre__order__iterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree_1_1sibling__iterator.html">sibling_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator which traverses only the nodes which are siblings of each other.  <a href="classtree_1_1sibling__iterator.html#_details">More...</a><br></td></tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="tree_8hh-source.html">tree.hh</a><li><a class="el" href="fx-0_88_82_2lib_2tree_8hh-source.html">fx-0.8.2/lib/tree.hh</a><li><a class="el" href="fx-0_89_80_2lib_2tree_8hh-source.html">fx-0.9.0/lib/tree.hh</a></ul>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Nov 19 20:28:01 2007 for LibOFX by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.3 </small></address>
</body>
</html>
